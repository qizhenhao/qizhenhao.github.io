---
title: BSP开发：IIC选通技术深度解析
date: 2025-06-28 1:00:00
tags:
  - BSP
  - IIC
  - 嵌入式
---

在嵌入式系统开发中，IIC (I²C) 总线是连接微控制器 (MCU) 与各种外设（如传感器、EEPROM 等）的常用通信协议。然而，当多个设备地址相同时，或需要挂载大量设备时，单一的 IIC 总线便会遇到瓶颈。本文将深入探讨如何通过 **IIC 选通 (IIC Multiplexing)** 技术来解决这一问题。

<!-- more -->

## 一、为什么需要 IIC 选通？

IIC 选通主要为了解决两个核心问题：
1.  **地址冲突**：多个同型号的 IIC 设备拥有相同的、固定的设备地址，无法直接挂载在同一条总线上。
2.  **总线扩展**：需要挂载的设备数量超过了 IIC 总线的负载能力或地址空间。

通过引入 **IIC 选通器 (IIC Multiplexer/Switch)**，例如经典的 `PCA9548A` (8路) 或 `PCA9546A` (4路)，我们就可以像切换电视频道一样，选择性地与某一个 IIC 设备进行通信。

## 二、IIC 选通器的工作原理

IIC 选通器本身也是一个标准的 IIC 从设备，拥有自己唯一的设备地址。主控 MCU 通过向这个特定地址发送控制命令，来打开或关闭其内部的某个或某些通道，从而将主 IIC 总线连接到指定的子总线上。

> **核心流程：** 主控 MCU → IIC 选通器 → 选通指定通道 → 主控 MCU 与目标设备通信。

## 三、BSP 层代码实现

在板级支持包 (BSP) 的设计中，我们需要将 IIC 选通的操作封装成简洁的接口，供上层应用调用。

以下是以 `PCA9548A` 为例的伪代码实现：

```c
#define PCA9548A_ADDR 0x70 // 选通器的 IIC 地址

/**
 * @brief 选择要打开的 IIC 通道
 * @param channel 要选择的通道号 (0-7)
 */
void iic_select_channel(uint8_t channel)
{
  // 控制字节的每一位对应一个通道，置 1 表示打开
  uint8_t control_byte = 1 << channel; 
  iic_master_write(PCA9548A_ADDR, &control_byte, 1);
}

/**
 * @brief 从指定通道的设备读取数据
 * @param channel 通道号
 * @param dev_addr 目标设备地址
 * @param buf 数据缓冲区
 * @param len 数据长度
 */
void iic_device_read(uint8_t channel, uint8_t dev_addr, uint8_t *buf, uint8_t len)
{
  // 步骤1: 选通指定的 IIC 通道
  iic_select_channel(channel);
  
  // 步骤2: 在选通的通道上与目标设备通信
  iic_master_read(dev_addr, buf, len);
}
```

## 四、进阶场景：多级 IIC 选通 (CPLD + IIC 选通器)

在某些复杂的硬件设计中，可能会遇到需要操作两次 IIC 才能完成选通的场景。例如，硬件手册要求先向 CPLD (地址 `0x21`) 写入一个值，再向 IIC 选通器 (地址 `0x70`) 写入另一个值。

这通常意味着系统中存在一个“多级选通”的结构。CPLD 在这里扮演了**第一级开关**或**总闸**的角色。不打开这个总闸，IIC 信号可能根本无法到达下一级的 IIC 选通器。

#### 硬件链路分析
这个硬件链路可以可视化为：
+-----------+ +----------------+ +--------------------------+ +-----------+
(一级开关)		(二级开关)		
+-----------+ +----------------+ +--------------------------+ +-----------+

#### 操作流程分析
1.  **操作 CPLD (0x21)**：这一步的目的是打开“总闸”，将主控的 IIC 总线物理连接到下一级的 IIC 选通器。
2.  **操作 IIC 选通器 (0x70)**：在总闸打开后，再操作这个“二级开关”，精细地选择最终要通信的目标设备通道。

#### 伪代码实现

```c
#define CPLD_IIC_ADDR 0x21
#define MUX_IIC_ADDR 0x70

void access_nested_iic_device(uint8_t cpld_cmd, uint8_t mux_channel, uint8_t dev_addr, uint8_t *buf, uint8_t len)
{
    // 步骤1: 操作 CPLD，打开 IIC 物理链路
    iic_master_write(CPLD_IIC_ADDR, &cpld_cmd, 1);

    // 步骤2: 操作 IIC 选通器，选择具体通道
    uint8_t mux_cmd = 1 << mux_channel;
    iic_master_write(MUX_IIC_ADDR, &mux_cmd, 1);

    // 步骤3: 访问最终的目标设备
    iic_master_read(dev_addr, buf, len);
}
```

## 五、设计建议与常见问题

> ### :bulb: 设计建议
> 1.  **抽象接口**：将复杂的选通逻辑封装成简洁的接口，上层应用无需关心底层细节。
> 2.  **互斥保护**：在多任务环境 (RTOS) 中，必须为 IIC 总线操作（包括选通和设备访问）添加互斥锁（Mutex），防止竞态条件。
> 3.  **错误处理**：完整地处理选通失败、设备无响应 (NACK) 等异常情况，保证系统的健壮性。


> ### :warning: 常见问题
> -   **忘记切换/关闭通道**：访问完一个设备后，未切换或关闭通道就去访问另一通道上的设备，导致访问错误。
> -   **地址冲突**：IIC 选通器自身的地址与总线上的某个外设地址重复。
> -   **总线拉电流能力**：挂载设备过多或总线过长，导致上拉电阻不匹配，波形异常，通信失败。


## 六、总结

IIC 选通是嵌入式系统中解决 IIC 总线地址冲突和扩展问题的关键技术。在 BSP 开发中，我们需要深刻理解其硬件原理，封装稳定可靠的软件接口，并充分考虑多级选通、多任务访问和错误处理等情况，才能构建出高效、健壮的嵌入式系统。