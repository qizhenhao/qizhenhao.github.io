[{"title":"力扣1031","slug":"力扣1031","date":"2023-04-26T06:15:00.000Z","updated":"2023-04-26T06:34:41.535Z","comments":true,"path":"2023/04/26/力扣1031/","link":"","permalink":"http://example.com/2023/04/26/%E5%8A%9B%E6%89%A31031/","excerpt":"#两个非重叠子数组的最大和","text":"#两个非重叠子数组的最大和 1031. 两个非重叠子数组的最大和 - 力扣（LeetCode）前缀和+动态规划：首先用前缀数组可以快速求出数组中两点中的元素的和，首先应该想象到找到first的元素的和，去遍历second的和找到最大和时间复杂度O(n^2),应该不难想到。 用动态规划去解决问题时，遍历一遍找到最大一个first的值，很简单就想到用一个 sum&#x3D;max(sum,s[i]-s[i-first]); 解决问题， 但是问题是求两端的和 有个方法很难想到，我反正是想不到，首先first与second的大小不同导致不清楚答案是谁在前谁在后 所以分开考虑假如second在前，则有在每次找first的最大时刻后面更新答案， sum &#x3D; max(sum,s[i-first]-s[i-first-second]); ans &#x3D; max(ans,sum+s[i]-s[i-first]); 同理另一种情况也是一样最终得出答案. 1234567891011121314151617181920212223class Solution &#123;public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; nums, int firstLen, int secondLen) &#123; int s[1001],n = nums.size(); s[0]=0; for(int i=1,sum=0;i&lt;=n;i++) &#123; sum+=nums[i-1]; s[i] = sum; &#125; int sum1=0,sum2=0,ans1=0,ans2=0; for(int i=firstLen+secondLen;i&lt;=n;i++) &#123; sum1 = max(sum1,s[i-secondLen]-s[i-secondLen-firstLen]); ans1 = max(ans1,sum1+s[i]-s[i-secondLen]); sum2 = max(sum2,s[i-firstLen]-s[i-firstLen-secondLen]); ans2 = max(ans2,sum2+s[i]-s[i-firstLen]); &#125; return max(ans1,ans2); &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"力扣1043和368","slug":"力扣1043和368","date":"2023-04-19T02:23:00.000Z","updated":"2023-04-19T12:34:42.457Z","comments":true,"path":"2023/04/19/力扣1043和368/","link":"","permalink":"http://example.com/2023/04/19/%E5%8A%9B%E6%89%A31043%E5%92%8C368/","excerpt":"#动态规划两道题","text":"#动态规划两道题 1043. 分隔数组以得到最大和 - 力扣（LeetCode）方法一（过不了）：树状数组＋dfs用dfs暴力搜索时间复杂度为指数型，用树状数组优化，但还是指数型 介绍一下树状数组： 【五分钟丝滑动画讲解 | 树状数组】 https://www.bilibili.com/video/BV1ce411u7qP/?share_source=copy_web&amp;vd_source=c9899d0504fa271ca6db5ef82d1a6bbb 树状数组的作用， 1.以O(logN)找到一个下表的 i 到 j 的和 2.以O(logN)更新一个下表的数字 3.空间复杂度为O(N) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;int&gt; tr; int lowerBit(int i) &#123; return (i&amp;-i); &#125; void add(int i,int z) &#123; for(;i&lt;tr.size();i+=lowerBit(i)) &#123; tr[i]+=z; &#125; &#125; int query(int i) &#123; int res=0; for(;i&gt;0;i-=lowerBit(i)) &#123; res+=tr[i]; &#125; return res; &#125;//树状数组的定义 int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; tr = vector&lt;int&gt;(arr.size()+1,0); int ma=0; function&lt;void(int)&gt; dfs = [&amp;](int dex)&#123; if(dex==arr.size())//下表超出，找到总和 &#123; ma = max(ma,query(tr.size()-1)); return; &#125; int res=0; for(int i=dex;i&lt;arr.size()&amp;&amp;i-dex&lt;k;i++) &#123; res = max(res,arr[i]); for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,res); &#125; dfs(i+1);//更新tr，递归后删除更新的数值 for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,-res); &#125; &#125; &#125;; dfs(0); return ma; &#125; &#125;; 方法二：dp简单分析一下找到数组的最大值，就是找到n的位置于n的前k项进行组合找到最大值 dp中储存的就是当前下表大小的数组的和最大值 推出动态方程 dp[i] &#x3D; max(dp[i],dp[j]+valmax*(i-j)); 12345678910111213141516171819class Solution &#123;public: int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; pd(arr.size()+1,0); //多一个是为了让以dp[0]=0开头，让下表i存的是前i项之和包括i for(int i=1;i&lt;arr.size()+1;i++) &#123; int maxv=arr[i-1]; for(int j=i-1;j&gt;=0&amp;&amp;i-j&lt;=k;j--) &#123; pd[i] = max(pd[i],pd[j]+(i-j)*maxv); if(j&gt;0) maxv = max(maxv,arr[j-1]); &#125; &#125; return pd[arr.size()]; &#125; &#125;; 时间复杂度O(NK) 空间是O(N) 368. 最大整除子集 - 力扣（LeetCode）dp+数学（简单的数学）：数学方面就是：在一个集合中使各个元素的最大公因数，最小公倍数是两个数本身 也就是说一个数能被另一个数整除 一个大于集合的所有数判断是否能被集合中所有元素整除，只需要判断能被集合中最大的数整除 所以先对nums排序 dp方程为dp[i] &#x3D; max(dp[j]+1); 保存最大的值，从最大的值开始往前找，找到连续可行的子序列 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;int&gt;ans; vector&lt;pair&lt;int,int&gt;&gt; mp(nums.size(),&#123;0,-1&#125;); int ma=-1,biao=0; for(int i=0;i&lt;nums.size();i++) &#123; for(int j=i-1;j&gt;=0;j--) &#123; if(nums[i]%nums[j]==0&amp;&amp;mp[i].first&lt;mp[j].first) &#123; mp[i].first = mp[j].first; mp[i].second = j; &#125; &#125; mp[i].first++; if(ma&lt;mp[i].first) &#123; ma = mp[i].first; biao = i; &#125; &#125; while(biao&gt;=0) &#123; ans.push_back(nums[biao]); biao = mp[biao].second; &#125; return ans; &#125;&#125;; 时间复杂度O(N^2) 空间复杂度O(2N)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"疫情在家有感","slug":"疫情在家有感","date":"2022-12-05T09:16:25.279Z","updated":"2022-12-05T09:27:16.914Z","comments":true,"path":"2022/12/05/疫情在家有感/","link":"","permalink":"http://example.com/2022/12/05/%E7%96%AB%E6%83%85%E5%9C%A8%E5%AE%B6%E6%9C%89%E6%84%9F/","excerpt":"我感觉吧，与其去羡慕别人的生活，不如好好享受自己的生活，哪怕你不喜欢。","text":"我感觉吧，与其去羡慕别人的生活，不如好好享受自己的生活，哪怕你不喜欢。 因为时间有限，每个人的时间都有限，你羡慕的人又高又帅，社交能力还强有很多朋友，孤独寂寞总轮不到他，但让自己处于羡慕这种人的痛苦之中，不如享受属于自己的快乐，或许这辈子也享受不到高富帅的快乐，但他们或许也享受不到屌丝的快乐，他的一生，我的一生都是美好的 浑浑噩噩的一天又要结束喽！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"wallhaven爬虫","slug":"wallhaven爬虫","date":"2022-12-04T16:19:14.000Z","updated":"2022-12-05T08:17:31.078Z","comments":true,"path":"2022/12/05/wallhaven爬虫/","link":"","permalink":"http://example.com/2022/12/05/wallhaven%E7%88%AC%E8%99%AB/","excerpt":"py爬取壁纸（setu）wallhaven网站爬取","text":"py爬取壁纸（setu）wallhaven网站爬取 刚开始爬的时候一切顺利，但最后遇到了反爬虫机制，就是必须要登录，否则无法显示一些色图。 首先想到的就是py模拟登录，这里说两种解法： ​ 1.在post请求中把账号，密码输入，一般都不会成功，应为会有js加密，这里可以解密，具体我也不了解就不往下说了 ​ 2.可行且简单的方法，用cookie绕过去，先说一下cookie的概念，在客户端对服务器发送请求，服务器会产生客户端的记录，来得知客户端之前做过什么，就比如你登录了bilbil，关了之后，在进入就免登录了，这之间就是cookie的功劳，让服务器记得你，回归正题，模拟登录就是首先你要登录这个网站，再记录cookie，爬取的headers填上cookie，让后就进入登录后的界面了，就可以下载图片了 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport parselimport osfor shuzi in range(1,75): print(f&quot;正在下载第&#123;shuzi&#125;页&quot;) url = &#x27;https://wallhaven.cc/hot?page=&#x27; #头请求就不展示了 headers = &#123; &#x27;user - agent&#x27;:#！！！这个网站的反爬虫机制就是登录，用cookie绕过登录----&gt; ,&#x27;cookie&#x27; : &#125; req = requests.get(url+str(shuzi),headers=headers,cookies=cook) print(url+str(shuzi)) sele = parsel.Selector(req.text) lis = sele.css(&#x27;.preview&#x27;) for li in lis: pic_url = li.css(&#x27;.preview ::attr(href)&#x27;).get() print(pic_url) pos = requests.get(pic_url,headers=headers,verify=False) pic_sele = parsel.Selector(pos.text) pic_lis = pic_sele.xpath(&#x27;//div[@class=&quot;scrollbox&quot;]//img/@src&#x27;).getall() print(pic_lis) for pic_urll in pic_lis: pic = requests.get(pic_urll,headers=headers,verify=False).content pic_name = pic_urll.split(&#x27;/&#x27;)[-1] if not os.path.exists(f&#x27;..//&#123;pic_name&#125;&#x27;): with open(f&#x27;..//&#123;pic_name&#125;&#x27;,&#x27;wb&#x27;) as f: f.write(pic) print(&#x27; 完成图片&#x27;+pic_name) else: print(&#x27; 已存在&#x27;+pic_name) 图片壁纸需要自取下面是wallhaven网站热门壁纸，果然色图是人的第一生产力，因为不能上传太多，就随便传了几张，可以尝试自己爬取哦","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"小齐的第一篇博客","slug":"齐振豪的第一篇博客","date":"2022-12-01T10:13:23.000Z","updated":"2023-04-19T12:35:07.319Z","comments":true,"path":"2022/12/01/齐振豪的第一篇博客/","link":"","permalink":"http://example.com/2022/12/01/%E9%BD%90%E6%8C%AF%E8%B1%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"#进来听听歌","text":"#进来听听歌 恭喜你，成功打开我的第一篇博客。 祝你的人生一路顺风，加油","categories":[],"tags":[]}]