[{"title":"HCIA：MAC地址补充和网络层","slug":"hcia/MAC地址加网络层","date":"2025-07-14T15:03:00.000Z","updated":"2025-07-14T15:04:14.882Z","comments":true,"path":"2025/07/14/hcia/MAC地址加网络层/","link":"","permalink":"http://example.com/2025/07/14/hcia/MAC%E5%9C%B0%E5%9D%80%E5%8A%A0%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"将上一节课中的MAC地址知识点补充，网络层的初步了解，学习IP报头。","text":"将上一节课中的MAC地址知识点补充，网络层的初步了解，学习IP报头。 MAC地址+网络层MAC地址mac地址 - 物理地址 - 网卡地址 网卡上 - 烧录进网卡芯片 - mac地址 单播MAC：点对点，一对一，类似于qq的私聊，数据封装时，源MAC和目的MAC都是单播MAC，则为单播通讯。单播的MAC地址的规则是从高位到低位的第8位为0，且一定为0，其他任意。 组播MAC：通讯形式上，点对多，单对多的通讯，类似于qq的群聊。组播MAC地址：从高位向低位，第8位为1，且一定为1。 数据封装时，因为组播代表的是一组的集合，面向一组的通讯，此时组播mac不能成为数据的源地址。仅能充当目的地址。 广播MAC：通讯形式上，点对所有，单对所有的通讯，广而播之。 数据封装时只能充当目的地址，从低位到高位全是1。 目的MAC为单播MAC单播数据到达后。 1、查看目的mac是否是自己的mac，如果不是丢弃，如果是，则进行下一步； 2、将数据进行crc校验，对比FCS 3、查看type字段，交给type字段交给上层协议处理。 数据链路工作结束 目的MAC为组播MAC组播数据到达后。 1、查看目的mac自己本地是否加组，如果不是丢弃，如果是，则进行下一步； 2、将数据进行crc校验，对比FCS 3、查看type字段，交给type字段交给上层协议处理。 数据链路工作结束 目的MAC为广播MAC广播数据到达后。 1、查看目的mac是否是广播，如果不是丢弃，如果是，则进行下一步； 2、将数据进行crc校验，对比FCS 3、查看type字段，交给type字段交给上层协议处理。 数据链路工作结束 网络层ip报文格式 报头最小是20字节，最后的ip options是可选项 刚开始的4字节 字段名 作用 比特位数 实际字节数 Version 标识IP协议版本（IPv4固定为 0100，IPv6为 0110）。 4 bits 0.5 字节 Header Length 表示IP头部的长度（以4字节为单位），范围515（即2060字节）。 4 bits 0.5 字节 DS Field 原为TOS（服务类型），现用于区分服务（如QoS优先级、流量类别）。 8 bits 1 字节 Total Length 整个IP数据包的总长度（包括头部+数据），最大65535字节（受MTU限制）。 16 bits 2 字节 identification、flag、fragment offsetIdentification（标识符） 作用：唯一标识同一个原始 IP 数据包的所有分片。 细节： 发送端为每个原始数据包分配一个 16 位唯一标识值（如随机数或递增计数器）。 所有属于该数据包的分片都携带相同的 Identification值，便于接收端重组时识别哪些分片属于同一数据包。 例如：若原始数据包 ID=12345被分成 3 片，所有分片的 ID均为 12345。 Flags（标志位） 作用：控制数据包的分片行为和重组状态。 细节（3 个标志位，图中未展示具体值）： 第一位（保留位）：恒为 0（未使用）。 DF（Don’t Fragment，禁止分片）： 若 DF=1，路由器禁止分片该数据包。若数据包超过 MTU，则丢弃并返回 ICMP “Fragmentation Needed” 错误（用于 PMTUD 路径 MTU 发现）。 MF（More Fragments，更多分片）： 若 MF=1，表示当前分片不是最后一个，后续还有分片。 若 MF=0，表示当前分片是最后一个分片或原始数据包未分片。 Fragment Offset（片偏移） 作用：指示当前分片在原始数据包中的位置，用于接收端按顺序重组。 细节： 以 8 字节为单位（即实际偏移量 &#x3D; 值 × 8）。 **第一个分片的偏移值为 0**，后续分片按数据长度递增。 例如：若原始数据包长 4000 字节，MTU&#x3D;1500： 分片1：偏移 0（携带 0~1479 字节，MF=1）。 分片2：偏移 185（1480~2959 字节，MF=1）。 分片3：偏移 370（2960~4000 字节，MF=0）。 三字段协作流程示例 发送端：数据包（ID=100, 长 3000 字节）需分片（MTU&#x3D;1500）。 分片1：ID=100, MF=1, Offset=0（0~1479 字节）。 分片2：ID=100, MF=0, Offset=185（1480~3000 字节）。 接收端：通过相同 ID识别分片，按 Offset排序，MF=0判断重组完成。 总结 **Identification**：分片归属的“身份证”。 **Flags**：控制分片行为（是否允许分片、是否还有后续分片）。 **Fragment Offset**：分片的“拼图位置”。 IPv6 区别：IPv6 已移除这些字段（仅允许源端分片，通过扩展头处理） TTL、Protocol、Header Checksum1. Time to Live (TTL) 位置：第9字节（8 bits）。 作用：防止数据包在网络中无限循环。 细节： 初始值：由发送端设置（如Windows默认 TTL=128，Linux默认 TTL=64）。 递减规则：每经过一个路由器（一跳）减1，当 TTL=0时，数据包被丢弃，并返回ICMP Time Exceeded错误。 实际用途： 限制数据包生存时间。 用于Traceroute工具（通过发送递增TTL的包探测路径）。 示例： 若 TTL=64，表示数据包最多可经过64跳路由设备。 2. Protocol 位置：第10字节（8 bits）。 作用：指示IP数据包内封装的上层协议类型。 常见协议号： 协议号（十进制） 协议 说明 1 ICMP 网络控制报文（如Ping）。 6 TCP 面向连接的可靠传输。 17 UDP 无连接的快速传输。 89 OSPF 路由协议。 示例： 若 Protocol=6，表示数据部分为TCP报文。 3. Header Checksum 位置：第11~12字节（16 bits）。 作用：校验IP头部的完整性（仅校验头部，不校验数据部分）。 计算规则： 发送端将头部按16位分组，所有分组求和（含校验和字段初始值 0x0000）。 对求和结果取反码（即1的补码），得到校验和。 接收端重新计算校验和，若结果不为 0xFFFF，则丢弃数据包。 示例： 若头部校验和为 0xABCD，接收端验证时需满足： Sum(所有16位分组) + 0xABCD = 0xFFFF。 三字段协作示例假设一个IPv4数据包的以下字段值： TTL=64（第9字节：0x40） Protocol=6（第10字节：0x06，表示TCP） Header Checksum=0x1234（第11~12字节：0x12 0x34） 抓包显示（十六进制）： 1... 40 06 12 34 ... ← 第9~12字节 解析： 40→ TTL&#x3D;64。 06→ 上层协议为TCP。 1234→ 头部校验和需接收端验证。 与IPv6的区别 TTL：IPv6中改名为 Hop Limit，功能相同。 Header Checksum：IPv6已移除，依赖链路层和传输层校验（如TCP&#x2F;UDP的校验和）。 总结 TTL：控制数据包生存时间，避免无限循环。 Protocol：决定数据部分交给哪个上层协议处理（如TCP&#x2F;UDP）。 Header Checksum：确保IP头部在传输中未被篡改或损坏。 关键性：这三个字段是IP通信可靠性和正确性的基础保障。 IP地址于IP可选项1. Source IP Address（源IP地址） 位置：IPv4头部的 第13~16字节（紧接在 Header Checksum之后）。 作用：标识发送数据包的设备IP地址（32位，IPv4格式）。 关键点： 必须是唯一可路由的地址（如 192.168.1.100）。 路由器根据目标地址转发数据包，但源地址用于回复通信（如TCP三次握手）。 NAT场景：经过NAT网关时，源地址会被替换为公网IP。 示例： 抓包中显示 Source IP: 192.168.1.100。 2. Destination IP Address（目标IP地址） 位置：IPv4头部的 第17~20字节。 作用：标识数据包的最终接收设备IP地址（32位）。 关键点： 可以是单播（如 10.0.0.1）、组播（如 224.0.0.5）或广播地址（如 255.255.255.255）。 路由器通过路由表决定如何转发到目标网络。 示例： 访问网站时，目标地址可能是 172.217.160.110（Google的IP）。 3. IP Options（IP选项） 位置：紧接在目标地址之后（第21字节开始，长度可变）。 作用：提供可选的扩展功能，通常为空（标准通信无需使用）。 常见选项类型： 选项名 功能说明 Record Route 记录数据包经过的路由器IP（用于路径追踪）。 Timestamp 记录经过每个路由器的时间戳。 Strict Source Route 强制指定数据包必须经过的路径。 注意事项： 选项字段长度可变，需通过 Header Length字段计算（若 IHL &gt; 5表示有选项）。 现代网络极少使用（可能被防火墙丢弃）。 示例： 若 Header Length=6（即头部24字节），则最后4字节为选项字段。 三字段在IPv4头部中的位置1234567891011121314150 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| IHL | DS Field | Total Length | ← 前4字节+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification |Flags| Fragment Offset | ← 分片字段+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time to Live | Protocol | Header Checksum | ← TTL等+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source IP Address | ← 第13~16字节+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination IP Address | ← 第17~20字节+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options (if IHL &gt; 5) | ← 可选+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 总结 源&#x2F;目标IP地址：是IP通信的基础，决定了数据包的起点和终点。 IP选项：提供高级功能，但实际使用较少。 图片中的红色标记：可能强调源地址的重要性（如配置NAT或过滤规则时需重点关注）。","categories":[],"tags":[{"name":"HCIA","slug":"HCIA","permalink":"http://example.com/tags/HCIA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"HCIA：数据链路层与MAC地址","slug":"hcia/数据链路层与MAC地址","date":"2025-07-09T16:15:00.000Z","updated":"2025-07-14T15:06:26.030Z","comments":true,"path":"2025/07/10/hcia/数据链路层与MAC地址/","link":"","permalink":"http://example.com/2025/07/10/hcia/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8EMAC%E5%9C%B0%E5%9D%80/","excerpt":"今天是看了HCIA的第三节课，加油！","text":"今天是看了HCIA的第三节课，加油！ 数据链路层与MAC地址以太网帧结构 Ethernet_IImac地址：物理地址：网卡地址； 每个设备出厂时，抄录进网卡芯片中，出厂自带，在一个以太网中，用来表示一个设备在什么位置。 smac：原mac； dmac：目的mac Type：类型 表示上层协议 FCS：校验位，CRC循环冗余校验。ps:这个抓包一般是抓不到的，需要硬件与驱动支持，因为硬件一般校验这个位置不行就直接丢弃了到不了操作系统。 发送者的动作：有发送者填充源MAC，以及type表示上层协议，以及CRC冗余校验， 接收者的动作：1、首先看目的MAC地址，是否是自己的mac，如果不是则丢弃，是的话继续。2、将数据进行CRC检验，对比FCS字段，如果不同则丢弃。3、查看type字段，由type字段标识上层协议处理。 IEEE802.3 Length：标识上层长度 LLC：逻辑链路控制 ​ D.SAP 目标服务接入点，就是目标type ​ S.SAP 原服务接入点，就是源type ​ Control：保留值：0x03 SNAP：子网络服务接入点，如果采用公有化协议，这个字段是看不到的。 ​ Org Code： 机构标识。 ​ Type：私有化的协议标识。 字段区分机制： DSAP&#x2F;SSAP值0xAA是SNAP存在的关键标志。当这两个字段均为0xAA时，表示后续5字节的SNAP头部存在。 标准协议（如IP）会使用非0xAA的SAP值（如0x06），此时帧格式直接跳过SNAP部分。 Data长度因为802.3对比Ethernet_II少了8个字节，因为数据链路层的封装的数据多了8个字节 MTU是最大传输单元，工作与每条链路的。 可以分片就分片，不能就丢弃。看上层是否支持 一帧最少64字节有时需要pading：填充0 如何分辨是什么协议的帧主要看 Length&#x2F;Type 这个字段， 大于等于 1536 就是Ethernet_II，小于等于 1500 就是802.3的帧。","categories":[],"tags":[{"name":"HCIA","slug":"HCIA","permalink":"http://example.com/tags/HCIA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"HCIA：数据封装与传输介质","slug":"hcia/数据封装和传输介质","date":"2025-07-08T15:36:00.000Z","updated":"2025-07-08T15:40:14.273Z","comments":true,"path":"2025/07/08/hcia/数据封装和传输介质/","link":"","permalink":"http://example.com/2025/07/08/hcia/%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E5%92%8C%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8/","excerpt":"今天是看了HCIA的第二节课","text":"今天是看了HCIA的第二节课 数据封装、传输介质数据传输的形式1、电路交换电路只给一个人使用，其他人无法使用，传输效率低，打电话目前就是电路交换。（计算机已经不使用了） 2、分组交换 目标提升利用率 如果做到知道是谁发送的数据，在数据之外加一层标识（就像快递的标签）。 分配问题，多个人同时转发的时候，交换机怎么转发，分片，设置MTU最大的片大小，分的片不能大于交换机规定的片，这样的话，一个人传输的数据大，就多传几次，一个人的片小就少传几次，更公平（好的故事都在将一个故事：)）。 封装与解封装 所有的封装都是为了，让快递公司（switchs）将data传给对方。 S:switch R:Route 封装解封装参考俄罗斯套娃 传输介质在网络诞生之前呢，可以用软盘硬盘刻录的形式同步数据。 后面用网卡和网线 网卡是翻译bit流，网线是承载bit流。 同轴电缆 根据曼彻斯特编码传输信号 一般用于监控，不会出现在网络架构中，使用的拓扑图一般都是多台设备在一根线上传输，也叫共享性网络。 会发生冲突域，用CSMA&#x2F;CD解决，随着设备的越来越多就冲突会导致多，就卡。 载波侦听多路检测、冲突检测技术，先听后发，但是同时发送呢？边发边听，一旦检测到冲突冲突停发，会有一个退避算法（随即延迟后重发）， 冲突域：问ai吧，走神了。 CSMA、CD：载波侦听多路检测、冲突检测技术 双绞线 STP:隔离双绞线 UTP:普通双绞线 5类双绞线：下左 6类双绞线：下右 双绞线的制作标准*线序： 568A - 白绿、绿、白橙、蓝、白蓝、橙、白棕、棕 568B - 白橙、橙、白绿、蓝、白蓝、绿、白棕、棕 10BASE-T: 10Mbps、 base：基带传输、T：双绞线类型 双绞线是全双工，4根8芯，4根发4根收 光纤 通过光传输，而不是电平 串口电缆 比较稳定，串行传输的，但是一般不用于网络中的，在工业上会有使用。 教学视频来自B站： 新版华为HCIA-2.数据封装+传输介质_哔哩哔哩_bilibili 京阿尼又出新动漫了，《小城日常》今天晚上看一集，今天就到这里886。","categories":[],"tags":[{"name":"HCIA","slug":"HCIA","permalink":"http://example.com/tags/HCIA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"HCIA：网络基本概念","slug":"hcia/网络基本概念","date":"2025-07-04T15:18:00.000Z","updated":"2025-07-08T15:40:29.871Z","comments":true,"path":"2025/07/04/hcia/网络基本概念/","link":"","permalink":"http://example.com/2025/07/04/hcia/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"简单的介绍了一下网络的基本概念。","text":"简单的介绍了一下网络的基本概念。 网络的历史数通为什么产生？1946年：世界上第一台计算机的诞生，主要是做 军事、科研 进行高速运算。 1962年：古巴导弹危机， 1969年：美国国防部高级研究计划书ARPA， “巨型网络” –ARPAnet 基于卫星实现数据的共享，提出思路：网络世界的万物互联 厂商垄断 – 不能大规模普及，每个厂商都单独定义标准。 问题：网络没有标准 1977年：TCP&#x2F;IP 架构（标准） 1980年：ARPAnet 全面向 TCP&#x2F;IP 架构进行迁移。 1984年：ISO - 国际标准化组织机构（定义各行各业的标准）OSI：开放系统互连。同时，TCP&#x2F;IP 模型全面推出。 工业标准：设备上使用的是 通信性的标准 TCP&#x2F;IP 1、统一化 2、分层管理 3、故障定位比较明确 OSI：7层模型7-应用层 ：满足下层无法解决的问题。 6-表示层 5-会话层 ：实现数据的编译与解码 ———不同领域分水岭———- 4-传输层 ：设备上的应用的区分（端口），可能基于不同的协议完成纠错。 3-网络层 ：ip地址，与mac地址协同生效，路由功能 2-数据链路层 ：差错检验，mac地址（两台相邻的设备之间的通讯）。 1-物理层 ：传输介质、硬件。 TCP&#x2F;IP：4层模型4-应用层 3-传输层 传输控制协议 2-网络层 互联网协议 1-网络接口层 网络架构 ISP &#x3D;&#x3D; 运营商【电信、移动、联通】 学习链接： 华为的协议地图：协议地图 后续任务：安装网络模拟软件，比如 eNSP。","categories":[],"tags":[{"name":"HCIA","slug":"HCIA","permalink":"http://example.com/tags/HCIA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"BSP开发：IIC选通技术深度解析","slug":"iic/index","date":"2025-06-27T17:00:00.000Z","updated":"2025-07-01T14:48:00.636Z","comments":true,"path":"2025/06/28/iic/index/","link":"","permalink":"http://example.com/2025/06/28/iic/index/","excerpt":"在嵌入式系统开发中，IIC (I²C) 总线是连接微控制器 (MCU) 与各种外设（如传感器、EEPROM 等）的常用通信协议。然而，当多个设备地址相同时，或需要挂载大量设备时，单一的 IIC 总线便会遇到瓶颈。本文将深入探讨如何通过 IIC 选通 (IIC Multiplexing) 技术来解决这一问题。","text":"在嵌入式系统开发中，IIC (I²C) 总线是连接微控制器 (MCU) 与各种外设（如传感器、EEPROM 等）的常用通信协议。然而，当多个设备地址相同时，或需要挂载大量设备时，单一的 IIC 总线便会遇到瓶颈。本文将深入探讨如何通过 IIC 选通 (IIC Multiplexing) 技术来解决这一问题。 一、为什么需要 IIC 选通？IIC 选通主要为了解决两个核心问题： 地址冲突：多个同型号的 IIC 设备拥有相同的、固定的设备地址，无法直接挂载在同一条总线上。 总线扩展：需要挂载的设备数量超过了 IIC 总线的负载能力或地址空间。 通过引入 **IIC 选通器 (IIC Multiplexer&#x2F;Switch)**，例如经典的 PCA9548A (8路) 或 PCA9546A (4路)，我们就可以像切换电视频道一样，选择性地与某一个 IIC 设备进行通信。 二、IIC 选通器的工作原理IIC 选通器本身也是一个标准的 IIC 从设备，拥有自己唯一的设备地址。主控 MCU 通过向这个特定地址发送控制命令，来打开或关闭其内部的某个或某些通道，从而将主 IIC 总线连接到指定的子总线上。 核心流程： 主控 MCU → IIC 选通器 → 选通指定通道 → 主控 MCU 与目标设备通信。 三、BSP 层代码实现在板级支持包 (BSP) 的设计中，我们需要将 IIC 选通的操作封装成简洁的接口，供上层应用调用。 以下是以 PCA9548A 为例的伪代码实现： 12345678910111213141516171819202122232425262728#define PCA9548A_ADDR 0x70 // 选通器的 IIC 地址/** * @brief 选择要打开的 IIC 通道 * @param channel 要选择的通道号 (0-7) */void iic_select_channel(uint8_t channel)&#123; // 控制字节的每一位对应一个通道，置 1 表示打开 uint8_t control_byte = 1 &lt;&lt; channel; iic_master_write(PCA9548A_ADDR, &amp;control_byte, 1);&#125;/** * @brief 从指定通道的设备读取数据 * @param channel 通道号 * @param dev_addr 目标设备地址 * @param buf 数据缓冲区 * @param len 数据长度 */void iic_device_read(uint8_t channel, uint8_t dev_addr, uint8_t *buf, uint8_t len)&#123; // 步骤1: 选通指定的 IIC 通道 iic_select_channel(channel); // 步骤2: 在选通的通道上与目标设备通信 iic_master_read(dev_addr, buf, len);&#125; 四、进阶场景：多级 IIC 选通 (CPLD + IIC 选通器)在某些复杂的硬件设计中，可能会遇到需要操作两次 IIC 才能完成选通的场景。例如，硬件手册要求先向 CPLD (地址 0x21) 写入一个值，再向 IIC 选通器 (地址 0x70) 写入另一个值。 这通常意味着系统中存在一个“多级选通”的结构。CPLD 在这里扮演了第一级开关或总闸的角色。不打开这个总闸，IIC 信号可能根本无法到达下一级的 IIC 选通器。 硬件链路分析这个硬件链路可以可视化为：+———–+ +—————-+ +————————–+ +———–+(一级开关) (二级开关) +———–+ +—————-+ +————————–+ +———–+ 操作流程分析 **操作 CPLD (0x21)**：这一步的目的是打开“总闸”，将主控的 IIC 总线物理连接到下一级的 IIC 选通器。 **操作 IIC 选通器 (0x70)**：在总闸打开后，再操作这个“二级开关”，精细地选择最终要通信的目标设备通道。 伪代码实现123456789101112131415#define CPLD_IIC_ADDR 0x21#define MUX_IIC_ADDR 0x70void access_nested_iic_device(uint8_t cpld_cmd, uint8_t mux_channel, uint8_t dev_addr, uint8_t *buf, uint8_t len)&#123; // 步骤1: 操作 CPLD，打开 IIC 物理链路 iic_master_write(CPLD_IIC_ADDR, &amp;cpld_cmd, 1); // 步骤2: 操作 IIC 选通器，选择具体通道 uint8_t mux_cmd = 1 &lt;&lt; mux_channel; iic_master_write(MUX_IIC_ADDR, &amp;mux_cmd, 1); // 步骤3: 访问最终的目标设备 iic_master_read(dev_addr, buf, len);&#125; 五、设计建议与常见问题 :bulb: 设计建议 抽象接口：将复杂的选通逻辑封装成简洁的接口，上层应用无需关心底层细节。 互斥保护：在多任务环境 (RTOS) 中，必须为 IIC 总线操作（包括选通和设备访问）添加互斥锁（Mutex），防止竞态条件。 错误处理：完整地处理选通失败、设备无响应 (NACK) 等异常情况，保证系统的健壮性。 :warning: 常见问题 忘记切换&#x2F;关闭通道：访问完一个设备后，未切换或关闭通道就去访问另一通道上的设备，导致访问错误。 地址冲突：IIC 选通器自身的地址与总线上的某个外设地址重复。 总线拉电流能力：挂载设备过多或总线过长，导致上拉电阻不匹配，波形异常，通信失败。 六、总结IIC 选通是嵌入式系统中解决 IIC 总线地址冲突和扩展问题的关键技术。在 BSP 开发中，我们需要深刻理解其硬件原理，封装稳定可靠的软件接口，并充分考虑多级选通、多任务访问和错误处理等情况，才能构建出高效、健壮的嵌入式系统。","categories":[],"tags":[{"name":"BSP","slug":"BSP","permalink":"http://example.com/tags/BSP/"},{"name":"IIC","slug":"IIC","permalink":"http://example.com/tags/IIC/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"起点聊天室详细介绍以及开发日志","slug":"qidianliaotian/index","date":"2024-03-22T16:00:00.000Z","updated":"2025-07-01T14:48:00.639Z","comments":true,"path":"2024/03/23/qidianliaotian/index/","link":"","permalink":"http://example.com/2024/03/23/qidianliaotian/index/","excerpt":"#一个大型项目","text":"#一个大型项目 起点聊天室的详细介绍 本项目仍在持续更新中。 介绍起点聊天室项目包含了局域网和全局网络两大模块。 全局网模块 目的：以 QQ 为参照，熟悉大型即时通讯软件的开发流程。 服务端技术栈：Linux, C++, libevent 网络库, 线程池, 数据库连接池, 文件服务器, MySQL, Log4j 风格的日志框架, 单例模式, 观察者模式, gdb 调试工具。 客户端技术栈：Qt, 信号与槽, RAII, 文件 IO, 网络编程, 多线程, Json 解析。 主要功能 登录模块 通过文件 IO 保存登录过的用户头像、账号，并可选择性保存密码。 通过选择历史账号，自动填充头像和密码。 支持无账号密码直接登录局域网聊天。 实现自动登录、记住密码、找回密码、注册账号等基础功能。 个人信息模块 支持个人信息的修改与展示。 好友系统 支持添加好友。 聊天功能 实现一对一单人聊天。 实现多人在线群聊。 局域网模块 目的：开发一个在公司内部使用的轻量化聊天与文件传输工具，防止信息泄露，无需中心服务器。 技术栈：Qt Widget, C++, 网络编程, 文件 IO, UDP 广播, TCP 文件传输。 主要功能 实现局域网内所有用户的自动发现、群聊和私聊。 支持选择性地加入或创建群聊。 基于 TCP 的可靠文件传输。 开发日志 本日志仍在持续更新中。 登录模块前端展示 2024年3月23日开发了 login_dat 接口，用于通过字节流高效地存储和读取用户的头像、账号及密码。 接口设计 技术：利用 RAII 思想管理 user.dat 文件的资源，在构造时获取资源并初始化，在析构时自动关闭和保存。 login_dat() 构造函数：自动识别并创建 ./user.dat 文件。如果文件已存在，则自动读取数据到内存中的 user_info_list。 ~login_dat() 析构函数：将内存中 user_info_list 的最新状态写回 user.dat 文件。 write_user_info(const QPixmap &amp;avater, const QString &amp;name, const QString &amp;password=&quot;&quot;) 将新的用户信息写入 user_info_list。如果用户已存在，则不进行任何操作。 get_user_info_list() ---&gt; QVector&lt;user_info&gt;* 返回 user_info_list 的指针。 is_has(const QString&amp; name) ---&gt; bool 检查指定账号是否存在。 user.dat 字节流格式 1234[qint64: 用户列表数量] [byteArray: 用户1头像] -&gt; [QString: 用户1账号] -&gt; [qint64: 密码是否存在] -&gt; [QString: 用户1密码] [byteArray: 用户2头像] -&gt; [QString: 用户2账号] -&gt; [qint64: 密码是否存在] -&gt; [QString: 用户2密码] ... 开发难点 QPixmap 与 QByteArray 之间的转化 从 QByteArray 加载 QPixmap：QPixmap.loadFromData(QByteArray) 将 QPixmap 保存到 QByteArray：需要一个 QBuffer 作为中介。12345QByteArray bytes;QBuffer buffer(&amp;bytes);buffer.open(QIODevice::WriteOnly);pixmap.save(&amp;buffer, &quot;PNG&quot;); // formatbuffer.close(); 为什么需要 QBuffer？因为 QPixmap::save() 方法需要一个 QIODevice 设备作为写入目标，而 QByteArray 本身不是 QIODevice。QBuffer 可以将 QByteArray 包装成一个内存中的 QIODevice 设备，从而让 save() 方法可以将图片数据写入到这个字节数组中。 Log4j 日志框架框架分析 2024年3月26日断断续续分析了两天，大致框架终于搞懂了。日志系统主要分为四大模块：日志器 (Logger)、日志事件 (LogEvent)、格式化器 (Formatter) 和 **输出地 (Appender)**。 代码亮点： 使用宏定义简化字符串到枚举的转换，代码更简洁，但牺牲了一定的可读性。 12345678910111213logLevel::Level logLevel::FromString(std::string str)&#123;#define XX(xlevel, v) \\ if(#xlevel == str || #v == str) \\ return logLevel::xlevel; XX(DEBUG, debug); XX(INFO, info); XX(WARN, warn); XX(ERROR, erron); XX(FATAL, fatal);#undef XX return logLevel::UNKNOW;&#125; 复习 C&#x2F;C++ 的可变参数列表： 12345678910111213void logEvent::format(const char *fmt, ...)&#123; va_list al; va_start(al, fmt); char *buf = nullptr; // vasprintf会动态分配内存，需要手动free int len = vasprintf(&amp;buf, fmt, al); if(len != -1)&#123; m_ss &lt;&lt; std::string(buf, len); free(buf); &#125; va_end(al);&#125; va_list: 定义一个指向可变参数列表的指针。 va_start: 初始化 va_list 指针，使其指向第一个可变参数。 va_arg: 读取当前参数，并使指针后移。 va_end: 清理可变参数列表。 2024年3月29日通过 gdb 调试，终于把日志系统的核心业务逻辑彻底搞懂了。这是一个典型的责任链与多态结合的设计模式。 核心流程： **日志管理器 (LoggerManager)**：采用单例模式管理所有的日志器。默认会创建一个名为 root 的根日志器。 **日志器 (Logger)**：root 日志器在构造时，会默认创建一个标准输出 StdOutAppender 和一个默认格式 DefaultFormatter。 **事件 (LogEvent)**：当代码中产生一条日志时，会创建一个 LogEvent 对象。该对象必须关联一个 Logger。 **事件包装器 (LogEventWrap)**：LogEvent 通常被 LogEventWrap 包装。在 LogEventWrap 的析构函数中，它会调用 Logger 的写入函数，将 LogEvent 自身作为参数传入。 写入过程： Logger 收到 LogEvent 后，会遍历其下所有可用的 Appender 列表。 通过多态调用每个 Appender 的写入函数。 在 Appender 内部，再通过多态调用其关联的 Formatter 的解析函数。 Formatter 将日志格式字符串（如 &#96;%d","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"NAT与UPNP技术学习笔记","slug":"NAT_UPNP/index","date":"2023-07-13T13:19:14.000Z","updated":"2025-07-01T14:48:00.633Z","comments":true,"path":"2023/07/13/NAT_UPNP/index/","link":"","permalink":"http://example.com/2023/07/13/NAT_UPNP/index/","excerpt":"本文内容主要整理自胡军、周剑扬、师佳三位老师的论文《P2P 网络中 UPnP 穿越 NAT 的研究与实现》，并结合个人理解进行排版优化，仅供学习使用。","text":"本文内容主要整理自胡军、周剑扬、师佳三位老师的论文《P2P 网络中 UPnP 穿越 NAT 的研究与实现》，并结合个人理解进行排版优化，仅供学习使用。 0. 引言在 IPv4 的地址空间日益紧张的背景下，网络地址转换（NAT）技术被广泛应用以实现 IP 地址的重用。这虽然缓解了地址枯竭问题，但也给 P2P (Peer-to-Peer) 应用带来了巨大的通信障碍： 单向访问：位于 NAT 后面的内网节点（拥有私有 IP）可以主动访问公网，但公网节点无法主动访问内网节点。 服务限制：内网节点无法作为服务端为公网提供服务。 为了解决这些问题，学术界和工业界提出了多种 NAT 穿越方案，如服务器转发、反向连接以及 UDP 打洞等。本文将重点介绍一种利用 UPnP (Universal Plug and Play) 技术，通过其自动端口映射 (Auto-Port-Mapping) 功能来实现 NAT 穿越的方案。 1. UPnP 穿越 NAT 的原理与实现1.1 核心原理UPnP 穿越 NAT 的核心思想是：在 NAT 设备上动态地创建一个临时的”端口转发”规则。 具体流程如下： 内网的客户端程序通过 UPnP 协议，请求其所在的 NAT 设备（通常是路由器）将某个公网端口（如 8081）的所有流量，转发到该客户端的内网 IP 和指定端口（如 192.168.1.100:8080）。 客户端将这个成功映射的公网 IP 和端口（公网IP:8081）注册到一个公网服务器上。 当另一个 P2P 节点（例如节点 B）想要与这个客户端（节点 A）通信时，它从公网服务器获取节点 A 注册的公网地址信息。 节点 B 直接向节点 A 的 公网IP:8081 发送数据，NAT 设备会根据之前创建的映射规则，自动将数据转发给内网的节点 A，从而实现穿越。 1.2 自动端口映射的程序设计根据 UPnP 规范，实现自动端口映射主要涉及以下几个步骤： 发现 (Discovery) 客户端向 UPnP 的标准多播地址 239.255.255.250:1900 发送一个 M-SEARCH 查找请求。 网络中支持 UPnP 的 NAT 设备（路由器）会响应这个请求，并回复一个包含设备描述文件 URL 的消息。 描述 (Description) 客户端通过上一步获取的 URL，下载一个 XML 格式的设备描述文件。 解析这个 XML 文件，可以得到设备的详细信息，包括设备类型、服务列表以及最重要的——控制 URL。 控制 (Control) 客户端向第二步获取的控制 URL 发送一个遵循 SOAP 协议的 XML 控制消息。 通过发送不同的控制消息，可以实现端口映射的增加 (AddPortMapping)、删除 (DeletePortMapping) 或查询 (GetPortMapping) 等操作。 原论文作者将这些功能用 C++ 封装成了一个名为 upnpd.dll 的动态链接库，以便于客户端程序调用。 2. 系统两端的程序设计2.1 服务器端服务器在整个方案中扮演”中间人”的角色，其功能相对简单： 记录所有客户端登录时注册的公网端口映射信息。 处理客户端的登录、登出请求。 响应客户端获取其他在线用户列表的请求。这种方式极大地减轻了服务器的负担，避免了在服务器上直接转发所有 P2P 流量，节约了服务器资源和带宽。 2.2 客户端客户端的功能则相对复杂： 启动后，创建一个本地 Socket 并绑定到固定端口（如 8080）。 连接公网服务器，并从服务器获取经过 NAT 转换后的公网 IP 和端口（如 公网IP:8081）。 判断自身是否位于 NAT 之后。如果是，则调用 AddPortMapping 函数，请求路由器将公网端口 8081 映射到内网端口 8080。 通过 Getu 命令从服务器获取在线用户列表。 通过 Send 命令与其他客户端直接通信。 退出时，通过 Exit 命令调用 DeletePortMapping 函数，删除之前建立的端口映射。 3. 结论使用 UPnP 的自动端口映射功能进行 NAT 穿越，是一种高效且可靠的 P2P 通信方案。它适用于客户端位于单个 NAT 之后的多种网络情况。 此方案建立的端口映射通常是静态的，即使用户在一段时间内没有数据收发，映射关系也不会被 NAT 设备自动收回。这保证了 P2P 连接的稳定性和可靠性，是实现真正意义上直接通信的关键。 4. 参考文献 UPnP 论坛贡献成员. PnP 设备架构[S]. UPnP 标准组织委员会, 2000: 2-11. 林丽闽, 别红霞等译. 标准 C++宝典[M]. 北京: 电子工业出版社, 2001. Bryan Ford, Pyda Srisuresh, Dan Kegel. Peer-to-Peer(P2P) Communication Across Network Address Translators(NATs) [DB&#x2F;OL]. 2004-12-12. 李河, 王树明. P2P 网络中使用 UDP 穿越 NAT 的方法研究[J]. 吉林大学学报(信息科学版), 2003, 21(3). 刘扬, 董开坤, 刘杨, 迟乐军. 对等网络中穿越 NAT 解决方案的研究[J]. 计算机工程与设计, 2008, 6(29).","categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"http://example.com/tags/%E8%AE%A1%E7%BD%91/"},{"name":"P2P","slug":"P2P","permalink":"http://example.com/tags/P2P/"},{"name":"NAT","slug":"NAT","permalink":"http://example.com/tags/NAT/"}]},{"title":"MySql 全方位学习笔记","slug":"MySql/index","date":"2023-06-13T13:56:14.000Z","updated":"2025-07-01T14:48:00.630Z","comments":true,"path":"2023/06/13/MySql/index/","link":"","permalink":"http://example.com/2023/06/13/MySql/index/","excerpt":"MySql 学习大全","text":"MySql 学习大全 MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面是最好的 RDBMS(Relational Database Management System) 应用软件之一。 什么是数据库？数据库（Database）是按照特定数据结构来组织、存储和管理数据的仓库。 虽然我们可以将数据存储在普通文件中，但当数据量庞大时，在文件中进行读写、查找和管理的效率会变得非常低下。 因此，现代应用普遍使用关系型数据库管理系统（RDBMS）来高效地存储和管理海量数据。所谓的关系型数据库，是建立在关系模型基础上的数据库，它借助于集合代数等数学概念和方法来处理数据。 RDBMS 的特点 **数据以表格的形式出现 (Table)**：这是关系型数据库的核心。 **每行为一条记录 (Row&#x2F;Record)**：代表一个实体的一组相关数据。 **每列为一个字段 (Column&#x2F;Field)**：包含同一种类型的数据。 许多的行和列组成一张**表 (Table)**。 若干的表组成一个**数据库 (Database)**。 RDBMS 核心术语 数据库 (Database): 是一些关联表的集合。 数据表 (Table): 表是数据的矩阵，看起来像一个简单的电子表格。 列 (Column): 一列(数据元素) 包含了相同类型的数据, 例如邮政编码。 行 (Row): 一行（也称元组或记录）是一组相关的数据，例如一条用户信息。 主键 (Primary Key): 表中的唯一标识符。一个数据表中只能包含一个主键，用于快速查询和保证数据唯一性。 外键 (Foreign Key): 用于在一个表中引用另一个表中的记录，以建立两个表之间的关联。 复合键 (Composite Key): 将多个列组合起来作为一个主键或唯一索引。 索引 (Index): 一种特殊的数据结构，用于快速访问数据库表中的特定信息，类似于书籍的目录，可以极大地提高查询速度。 参照完整性 (Referential Integrity): 要求关系中不允许引用不存在的实体。这是保证数据一致性的重要约束。 MySql 安装指南 (Windows)1. 下载 MySql访问官方下载地址: https://dev.mysql.com/downloads/mysql/ 2. 解压缩将下载的压缩包解压到一个合适的目录，注意：路径中不能包含中文或空格。 3. 配置环境变量将 MySQL 的 bin 目录路径（例如 D:\\dev\\mysql-8.0.27-winx64\\bin）添加到系统的 Path 环境变量中。 4. 添加配置文件 my.ini【选做】 此步骤可选，如果不创建，MySql 会使用系统默认配置。 在 MySQL 的根目录中，手动创建一个名为 my.ini 的文件。 将以下内容复制到 my.ini 中，并务必修改 basedir 和 datadir 为你自己的实际路径。 1234567891011121314151617181920212223242526[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\\\dev\\\\mysql-8.0.27-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\\\dev\\\\mysql-8.0.27-winx64\\\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用&quot;mysql_native_password&quot;插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 5. 初始化数据库以管理员身份运行命令提示符 (CMD)。 在 CMD 中执行以下命令，MySQL 会进行初始化并生成一个临时密码，请务必复制并保存好这个密码。 1mysqld --initialize --console 6. 安装 MySql 服务继续在管理员 CMD 中执行以下命令来安装 MySQL 服务： 1mysqld --install 7. 启动服务使用以下命令启动 MySQL 服务： 1net start mysql 8. 登录 MySql 并修改密码 在 CMD 中，输入以下命令并按回车： 1mysql -uroot -p 提示 Enter password: 后，粘贴你之前保存的临时密码，然后按回车。 登录成功后，立即执行以下 SQL 语句来修改为您自己的新密码（例如 12345678）： 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;12345678&#x27;; 9. 卸载 MySql（备用）如果需要卸载 MySQL，请按以下步骤操作： 停止服务 (管理员 CMD):1net stop mysql 移除服务 (管理员 CMD):1mysqld --remove 手动删除 MySQL 的安装文件夹。 可视化连接工具：Navicat为了更方便地管理数据库，我们可以使用图形化界面工具。Navicat 是其中非常流行的一款。 下载与安装 官网下载: https://www.navicat.com.cn/download/navicat-premium 安装: 下载后双击 .exe 文件，按提示进行可视化安装即可。 新建连接 在 Navicat 中，点击”连接” -&gt; “MySQL”，然后输入连接名、主机（localhost）、端口（3306）、用户名（root）和你刚才设置的新密码，点击”连接测试”，成功后保存即可。 SQL 入门数据库、表、数据的关系 数据库 (Database): 存储和管理数据的仓库，一个库可以包含多个数据表。 数据表 (Table): 数据库中最重要的组成部分，由行和列组成，类似 Excel 表格。 数据 (Data): 表中存储的一行行具体信息，是我们真正要管理的内容。 SQL 语言介绍 什么是 SQL? Structured Query Language，即结构化查询语言。 它是操作所有关系型数据库的国际标准。不同的数据库可能会在标准 SQL 的基础上增加一些自己特有的语法，我们称之为”方言”。 SQL 通用语法 SQL 语句可以单行或多行书写，通常以分号 (;) 结尾。 可使用空格和缩进来增强语句的可读性。 SQL 语句不区分大小写，但业界约定关键字使用大写，表名和列名使用小写。 注释: 单行注释: -- 注释内容 或 # 注释内容 (MySQL 特有) 多行注释: /* 注释内容 */","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"力扣1031","slug":"力扣1031/index","date":"2023-04-26T06:15:00.000Z","updated":"2025-07-01T14:48:00.645Z","comments":true,"path":"2023/04/26/力扣1031/index/","link":"","permalink":"http://example.com/2023/04/26/%E5%8A%9B%E6%89%A31031/index/","excerpt":"#两个非重叠子数组的最大和","text":"#两个非重叠子数组的最大和 1031. 两个非重叠子数组的最大和 - 力扣（LeetCode）前缀和+动态规划：首先用前缀数组可以快速求出数组中两点中的元素的和，首先应该想象到找到first的元素的和，去遍历second的和找到最大和时间复杂度O(n^2),应该不难想到。 用动态规划去解决问题时，遍历一遍找到最大一个first的值，很简单就想到用一个 sum&#x3D;max(sum,s[i]-s[i-first]); 解决问题， 但是问题是求两端的和 有个方法很难想到，我反正是想不到，首先first与second的大小不同导致不清楚答案是谁在前谁在后 所以分开考虑假如second在前，则有在每次找first的最大时刻后面更新答案， sum &#x3D; max(sum,s[i-first]-s[i-first-second]); ans &#x3D; max(ans,sum+s[i]-s[i-first]); 同理另一种情况也是一样最终得出答案. 1234567891011121314151617181920212223class Solution &#123;public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; nums, int firstLen, int secondLen) &#123; int s[1001],n = nums.size(); s[0]=0; for(int i=1,sum=0;i&lt;=n;i++) &#123; sum+=nums[i-1]; s[i] = sum; &#125; int sum1=0,sum2=0,ans1=0,ans2=0; for(int i=firstLen+secondLen;i&lt;=n;i++) &#123; sum1 = max(sum1,s[i-secondLen]-s[i-secondLen-firstLen]); ans1 = max(ans1,sum1+s[i]-s[i-secondLen]); sum2 = max(sum2,s[i-firstLen]-s[i-firstLen-secondLen]); ans2 = max(ans2,sum2+s[i]-s[i-firstLen]); &#125; return max(ans1,ans2); &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"力扣1043和368","slug":"力扣1043和368/index","date":"2023-04-19T02:23:00.000Z","updated":"2025-07-01T14:48:00.647Z","comments":true,"path":"2023/04/19/力扣1043和368/index/","link":"","permalink":"http://example.com/2023/04/19/%E5%8A%9B%E6%89%A31043%E5%92%8C368/index/","excerpt":"#动态规划两道题","text":"#动态规划两道题 1043. 分隔数组以得到最大和 - 力扣（LeetCode）方法一（过不了）：树状数组＋dfs用dfs暴力搜索时间复杂度为指数型，用树状数组优化，但还是指数型 介绍一下树状数组： 【五分钟丝滑动画讲解 | 树状数组】 https://www.bilibili.com/video/BV1ce411u7qP/?share_source=copy_web&amp;vd_source=c9899d0504fa271ca6db5ef82d1a6bbb 树状数组的作用， 1.以O(logN)找到一个下表的 i 到 j 的和 2.以O(logN)更新一个下表的数字 3.空间复杂度为O(N) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;int&gt; tr; int lowerBit(int i) &#123; return (i&amp;-i); &#125; void add(int i,int z) &#123; for(;i&lt;tr.size();i+=lowerBit(i)) &#123; tr[i]+=z; &#125; &#125; int query(int i) &#123; int res=0; for(;i&gt;0;i-=lowerBit(i)) &#123; res+=tr[i]; &#125; return res; &#125;//树状数组的定义 int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; tr = vector&lt;int&gt;(arr.size()+1,0); int ma=0; function&lt;void(int)&gt; dfs = [&amp;](int dex)&#123; if(dex==arr.size())//下表超出，找到总和 &#123; ma = max(ma,query(tr.size()-1)); return; &#125; int res=0; for(int i=dex;i&lt;arr.size()&amp;&amp;i-dex&lt;k;i++) &#123; res = max(res,arr[i]); for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,res); &#125; dfs(i+1);//更新tr，递归后删除更新的数值 for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,-res); &#125; &#125; &#125;; dfs(0); return ma; &#125; &#125;; 方法二：dp简单分析一下找到数组的最大值，就是找到n的位置于n的前k项进行组合找到最大值 dp中储存的就是当前下表大小的数组的和最大值 推出动态方程 dp[i] &#x3D; max(dp[i],dp[j]+valmax*(i-j)); 12345678910111213141516171819class Solution &#123;public: int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; pd(arr.size()+1,0); //多一个是为了让以dp[0]=0开头，让下表i存的是前i项之和包括i for(int i=1;i&lt;arr.size()+1;i++) &#123; int maxv=arr[i-1]; for(int j=i-1;j&gt;=0&amp;&amp;i-j&lt;=k;j--) &#123; pd[i] = max(pd[i],pd[j]+(i-j)*maxv); if(j&gt;0) maxv = max(maxv,arr[j-1]); &#125; &#125; return pd[arr.size()]; &#125; &#125;; 时间复杂度O(NK) 空间是O(N) 368. 最大整除子集 - 力扣（LeetCode）dp+数学（简单的数学）：数学方面就是：在一个集合中使各个元素的最大公因数，最小公倍数是两个数本身 也就是说一个数能被另一个数整除 一个大于集合的所有数判断是否能被集合中所有元素整除，只需要判断能被集合中最大的数整除 所以先对nums排序 dp方程为dp[i] &#x3D; max(dp[j]+1); 保存最大的值，从最大的值开始往前找，找到连续可行的子序列 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;int&gt;ans; vector&lt;pair&lt;int,int&gt;&gt; mp(nums.size(),&#123;0,-1&#125;); int ma=-1,biao=0; for(int i=0;i&lt;nums.size();i++) &#123; for(int j=i-1;j&gt;=0;j--) &#123; if(nums[i]%nums[j]==0&amp;&amp;mp[i].first&lt;mp[j].first) &#123; mp[i].first = mp[j].first; mp[i].second = j; &#125; &#125; mp[i].first++; if(ma&lt;mp[i].first) &#123; ma = mp[i].first; biao = i; &#125; &#125; while(biao&gt;=0) &#123; ans.push_back(nums[biao]); biao = mp[biao].second; &#125; return ans; &#125;&#125;; 时间复杂度O(N^2) 空间复杂度O(2N)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"wallhaven爬虫","slug":"wallhaven爬虫/index","date":"2022-12-04T16:19:14.000Z","updated":"2025-07-01T14:48:00.642Z","comments":true,"path":"2022/12/05/wallhaven爬虫/index/","link":"","permalink":"http://example.com/2022/12/05/wallhaven%E7%88%AC%E8%99%AB/index/","excerpt":"py爬取壁纸（setu）wallhaven网站爬取","text":"py爬取壁纸（setu）wallhaven网站爬取 刚开始爬的时候一切顺利，但最后遇到了反爬虫机制，就是必须要登录，否则无法显示一些色图。 首先想到的就是 py 模拟登录，这里说两种解法： 在 post 请求中把账号，密码输入，一般都不会成功，因为会有 JS 加密。这里可以解密，但具体我也不了解就不往下说了。 可行且简单的方法，用 Cookie 绕过去。先说一下 Cookie 的概念：在客户端对服务器发送请求，服务器会产生客户端的记录，来得知客户端之前做过什么。就比如你登录了 Bilibili，关了之后再进入就免登录了，这之间就是 Cookie 的功劳，让服务器记得你。回归正题，模拟登录就是首先你要登录这个网站，再记录 Cookie，爬取的 headers 填上 Cookie，然后就进入登录后的界面了，就可以下载图片了。 12345678910111213141516171819202122232425262728293031323334353637383940import requestsimport parselimport osfor shuzi in range(1,75): print(f&quot;正在下载第&#123;shuzi&#125;页&quot;) url = &#x27;https://wallhaven.cc/hot?page=&#x27; # 头请求就不展示了 # ！！！这个网站的反爬虫机制就是登录，用cookie绕过登录----&gt; headers = &#123; &#x27;user-agent&#x27;: &#x27;your-user-agent-string&#x27;, &#x27;cookie&#x27; : &#x27;your-cookie-string&#x27; &#125; # 此处的 cook 变量未定义，在实际运行时需要替换为您的 cookie 字典 req = requests.get(url+str(shuzi),headers=headers) print(url+str(shuzi)) sele = parsel.Selector(req.text) lis = sele.css(&#x27;.preview&#x27;) for li in lis: pic_url = li.css(&#x27;.preview ::attr(href)&#x27;).get() print(pic_url) pos = requests.get(pic_url,headers=headers,verify=False) pic_sele = parsel.Selector(pos.text) pic_lis = pic_sele.xpath(&#x27;//div[@class=&quot;scrollbox&quot;]//img/@src&#x27;).getall() print(pic_lis) for pic_urll in pic_lis: pic = requests.get(pic_urll,headers=headers,verify=False).content pic_name = pic_urll.split(&#x27;/&#x27;)[-1] if not os.path.exists(f&#x27;..//&#123;pic_name&#125;&#x27;): with open(f&#x27;..//&#123;pic_name&#125;&#x27;,&#x27;wb&#x27;) as f: f.write(pic) print(&#x27; 完成图片&#x27;+pic_name) else: print(&#x27; 已存在&#x27;+pic_name) 图片壁纸需要自取下面是wallhaven网站热门壁纸。果然，某些图片是第一生产力。因为不能上传太多，就随便传了几张，可以尝试自己爬取哦。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"小齐的第一篇博客","slug":"齐振豪的第一篇博客/index","date":"2022-12-01T10:13:23.000Z","updated":"2025-07-01T14:48:00.650Z","comments":true,"path":"2022/12/01/齐振豪的第一篇博客/index/","link":"","permalink":"http://example.com/2022/12/01/%E9%BD%90%E6%8C%AF%E8%B1%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/index/","excerpt":"进来听听歌","text":"进来听听歌 恭喜你，成功打开了我的第一篇博客！ 希望这首歌能给你带来好心情。祝你的人生，一路顺风！ 从这里开始，记录成长，分享生活。加油！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}]