[{"title":"BSP开发：IIC选通技术深度解析","slug":"iic","date":"2025-06-27T17:00:00.000Z","updated":"2025-06-27T17:29:49.698Z","comments":true,"path":"2025/06/28/iic/","link":"","permalink":"http://example.com/2025/06/28/iic/","excerpt":"在嵌入式系统开发中，IIC (I²C) 总线是连接微控制器 (MCU) 与各种外设（如传感器、EEPROM 等）的常用通信协议。然而，当多个设备地址相同时，或需要挂载大量设备时，单一的 IIC 总线便会遇到瓶颈。本文将深入探讨如何通过 IIC 选通 (IIC Multiplexing) 技术来解决这一问题。","text":"在嵌入式系统开发中，IIC (I²C) 总线是连接微控制器 (MCU) 与各种外设（如传感器、EEPROM 等）的常用通信协议。然而，当多个设备地址相同时，或需要挂载大量设备时，单一的 IIC 总线便会遇到瓶颈。本文将深入探讨如何通过 IIC 选通 (IIC Multiplexing) 技术来解决这一问题。 一、为什么需要 IIC 选通？IIC 选通主要为了解决两个核心问题： 地址冲突：多个同型号的 IIC 设备拥有相同的、固定的设备地址，无法直接挂载在同一条总线上。 总线扩展：需要挂载的设备数量超过了 IIC 总线的负载能力或地址空间。 通过引入 **IIC 选通器 (IIC Multiplexer&#x2F;Switch)**，例如经典的 PCA9548A (8路) 或 PCA9546A (4路)，我们就可以像切换电视频道一样，选择性地与某一个 IIC 设备进行通信。 二、IIC 选通器的工作原理IIC 选通器本身也是一个标准的 IIC 从设备，拥有自己唯一的设备地址。主控 MCU 通过向这个特定地址发送控制命令，来打开或关闭其内部的某个或某些通道，从而将主 IIC 总线连接到指定的子总线上。 核心流程： 主控 MCU → IIC 选通器 → 选通指定通道 → 主控 MCU 与目标设备通信。 三、BSP 层代码实现在板级支持包 (BSP) 的设计中，我们需要将 IIC 选通的操作封装成简洁的接口，供上层应用调用。 以下是以 PCA9548A 为例的伪代码实现： 12345678910111213141516171819202122232425262728#define PCA9548A_ADDR 0x70 // 选通器的 IIC 地址/** * @brief 选择要打开的 IIC 通道 * @param channel 要选择的通道号 (0-7) */void iic_select_channel(uint8_t channel)&#123; // 控制字节的每一位对应一个通道，置 1 表示打开 uint8_t control_byte = 1 &lt;&lt; channel; iic_master_write(PCA9548A_ADDR, &amp;control_byte, 1);&#125;/** * @brief 从指定通道的设备读取数据 * @param channel 通道号 * @param dev_addr 目标设备地址 * @param buf 数据缓冲区 * @param len 数据长度 */void iic_device_read(uint8_t channel, uint8_t dev_addr, uint8_t *buf, uint8_t len)&#123; // 步骤1: 选通指定的 IIC 通道 iic_select_channel(channel); // 步骤2: 在选通的通道上与目标设备通信 iic_master_read(dev_addr, buf, len);&#125; 四、进阶场景：多级 IIC 选通 (CPLD + IIC 选通器)在某些复杂的硬件设计中，可能会遇到需要操作两次 IIC 才能完成选通的场景。例如，硬件手册要求先向 CPLD (地址 0x21) 写入一个值，再向 IIC 选通器 (地址 0x70) 写入另一个值。 这通常意味着系统中存在一个“多级选通”的结构。CPLD 在这里扮演了第一级开关或总闸的角色。不打开这个总闸，IIC 信号可能根本无法到达下一级的 IIC 选通器。 硬件链路分析这个硬件链路可以可视化为：+———–+ +—————-+ +————————–+ +———–+(一级开关) (二级开关) +———–+ +—————-+ +————————–+ +———–+ 操作流程分析 **操作 CPLD (0x21)**：这一步的目的是打开“总闸”，将主控的 IIC 总线物理连接到下一级的 IIC 选通器。 **操作 IIC 选通器 (0x70)**：在总闸打开后，再操作这个“二级开关”，精细地选择最终要通信的目标设备通道。 伪代码实现123456789101112131415#define CPLD_IIC_ADDR 0x21#define MUX_IIC_ADDR 0x70void access_nested_iic_device(uint8_t cpld_cmd, uint8_t mux_channel, uint8_t dev_addr, uint8_t *buf, uint8_t len)&#123; // 步骤1: 操作 CPLD，打开 IIC 物理链路 iic_master_write(CPLD_IIC_ADDR, &amp;cpld_cmd, 1); // 步骤2: 操作 IIC 选通器，选择具体通道 uint8_t mux_cmd = 1 &lt;&lt; mux_channel; iic_master_write(MUX_IIC_ADDR, &amp;mux_cmd, 1); // 步骤3: 访问最终的目标设备 iic_master_read(dev_addr, buf, len);&#125; 五、设计建议与常见问题 :bulb: 设计建议 抽象接口：将复杂的选通逻辑封装成简洁的接口，上层应用无需关心底层细节。 互斥保护：在多任务环境 (RTOS) 中，必须为 IIC 总线操作（包括选通和设备访问）添加互斥锁（Mutex），防止竞态条件。 错误处理：完整地处理选通失败、设备无响应 (NACK) 等异常情况，保证系统的健壮性。 :warning: 常见问题 忘记切换&#x2F;关闭通道：访问完一个设备后，未切换或关闭通道就去访问另一通道上的设备，导致访问错误。 地址冲突：IIC 选通器自身的地址与总线上的某个外设地址重复。 总线拉电流能力：挂载设备过多或总线过长，导致上拉电阻不匹配，波形异常，通信失败。 六、总结IIC 选通是嵌入式系统中解决 IIC 总线地址冲突和扩展问题的关键技术。在 BSP 开发中，我们需要深刻理解其硬件原理，封装稳定可靠的软件接口，并充分考虑多级选通、多任务访问和错误处理等情况，才能构建出高效、健壮的嵌入式系统。","categories":[],"tags":[{"name":"BSP","slug":"BSP","permalink":"http://example.com/tags/BSP/"},{"name":"IIC","slug":"IIC","permalink":"http://example.com/tags/IIC/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"起点聊天室详细介绍以及开发日志","slug":"qidianliaotian","date":"2024-03-22T16:00:00.000Z","updated":"2025-06-27T17:33:29.066Z","comments":true,"path":"2024/03/23/qidianliaotian/","link":"","permalink":"http://example.com/2024/03/23/qidianliaotian/","excerpt":"#一个大型项目","text":"#一个大型项目 起点聊天室的详细介绍 本项目仍在持续更新中。 介绍起点聊天室项目包含了局域网和全局网络两大模块。 全局网模块 目的：以 QQ 为参照，熟悉大型即时通讯软件的开发流程。 服务端技术栈：Linux, C++, libevent 网络库, 线程池, 数据库连接池, 文件服务器, MySQL, Log4j 风格的日志框架, 单例模式, 观察者模式, gdb 调试工具。 客户端技术栈：Qt, 信号与槽, RAII, 文件 IO, 网络编程, 多线程, Json 解析。 主要功能 登录模块 通过文件 IO 保存登录过的用户头像、账号，并可选择性保存密码。 通过选择历史账号，自动填充头像和密码。 支持无账号密码直接登录局域网聊天。 实现自动登录、记住密码、找回密码、注册账号等基础功能。 个人信息模块 支持个人信息的修改与展示。 好友系统 支持添加好友。 聊天功能 实现一对一单人聊天。 实现多人在线群聊。 局域网模块 目的：开发一个在公司内部使用的轻量化聊天与文件传输工具，防止信息泄露，无需中心服务器。 技术栈：Qt Widget, C++, 网络编程, 文件 IO, UDP 广播, TCP 文件传输。 主要功能 实现局域网内所有用户的自动发现、群聊和私聊。 支持选择性地加入或创建群聊。 基于 TCP 的可靠文件传输。 开发日志 本日志仍在持续更新中。 登录模块前端展示 2024年3月23日开发了 login_dat 接口，用于通过字节流高效地存储和读取用户的头像、账号及密码。 接口设计 技术：利用 RAII 思想管理 user.dat 文件的资源，在构造时获取资源并初始化，在析构时自动关闭和保存。 login_dat() 构造函数：自动识别并创建 ./user.dat 文件。如果文件已存在，则自动读取数据到内存中的 user_info_list。 ~login_dat() 析构函数：将内存中 user_info_list 的最新状态写回 user.dat 文件。 write_user_info(const QPixmap &amp;avater, const QString &amp;name, const QString &amp;password=&quot;&quot;) 将新的用户信息写入 user_info_list。如果用户已存在，则不进行任何操作。 get_user_info_list() ---&gt; QVector&lt;user_info&gt;* 返回 user_info_list 的指针。 is_has(const QString&amp; name) ---&gt; bool 检查指定账号是否存在。 user.dat 字节流格式 1234[qint64: 用户列表数量] [byteArray: 用户1头像] -&gt; [QString: 用户1账号] -&gt; [qint64: 密码是否存在] -&gt; [QString: 用户1密码] [byteArray: 用户2头像] -&gt; [QString: 用户2账号] -&gt; [qint64: 密码是否存在] -&gt; [QString: 用户2密码] ... 开发难点 QPixmap 与 QByteArray 之间的转化 从 QByteArray 加载 QPixmap：QPixmap.loadFromData(QByteArray) 将 QPixmap 保存到 QByteArray：需要一个 QBuffer 作为中介。12345QByteArray bytes;QBuffer buffer(&amp;bytes);buffer.open(QIODevice::WriteOnly);pixmap.save(&amp;buffer, &quot;PNG&quot;); // formatbuffer.close(); 为什么需要 QBuffer？因为 QPixmap::save() 方法需要一个 QIODevice 设备作为写入目标，而 QByteArray 本身不是 QIODevice。QBuffer 可以将 QByteArray 包装成一个内存中的 QIODevice 设备，从而让 save() 方法可以将图片数据写入到这个字节数组中。 Log4j 日志框架框架分析 2024年3月26日断断续续分析了两天，大致框架终于搞懂了。日志系统主要分为四大模块：日志器 (Logger)、日志事件 (LogEvent)、格式化器 (Formatter) 和 **输出地 (Appender)**。 代码亮点： 使用宏定义简化字符串到枚举的转换，代码更简洁，但牺牲了一定的可读性。 12345678910111213logLevel::Level logLevel::FromString(std::string str)&#123;#define XX(xlevel, v) \\ if(#xlevel == str || #v == str) \\ return logLevel::xlevel; XX(DEBUG, debug); XX(INFO, info); XX(WARN, warn); XX(ERROR, erron); XX(FATAL, fatal);#undef XX return logLevel::UNKNOW;&#125; 复习 C&#x2F;C++ 的可变参数列表： 12345678910111213void logEvent::format(const char *fmt, ...)&#123; va_list al; va_start(al, fmt); char *buf = nullptr; // vasprintf会动态分配内存，需要手动free int len = vasprintf(&amp;buf, fmt, al); if(len != -1)&#123; m_ss &lt;&lt; std::string(buf, len); free(buf); &#125; va_end(al);&#125; va_list: 定义一个指向可变参数列表的指针。 va_start: 初始化 va_list 指针，使其指向第一个可变参数。 va_arg: 读取当前参数，并使指针后移。 va_end: 清理可变参数列表。 2024年3月29日通过 gdb 调试，终于把日志系统的核心业务逻辑彻底搞懂了。这是一个典型的责任链与多态结合的设计模式。 核心流程： **日志管理器 (LoggerManager)**：采用单例模式管理所有的日志器。默认会创建一个名为 root 的根日志器。 **日志器 (Logger)**：root 日志器在构造时，会默认创建一个标准输出 StdOutAppender 和一个默认格式 DefaultFormatter。 **事件 (LogEvent)**：当代码中产生一条日志时，会创建一个 LogEvent 对象。该对象必须关联一个 Logger。 **事件包装器 (LogEventWrap)**：LogEvent 通常被 LogEventWrap 包装。在 LogEventWrap 的析构函数中，它会调用 Logger 的写入函数，将 LogEvent 自身作为参数传入。 写入过程： Logger 收到 LogEvent 后，会遍历其下所有可用的 Appender 列表。 通过多态调用每个 Appender 的写入函数。 在 Appender 内部，再通过多态调用其关联的 Formatter 的解析函数。 Formatter 将日志格式字符串（如 &#96;%d","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"NAT与UPNP技术学习笔记","slug":"NAT_UPNP","date":"2023-07-13T13:19:14.000Z","updated":"2025-06-27T17:14:03.479Z","comments":true,"path":"2023/07/13/NAT_UPNP/","link":"","permalink":"http://example.com/2023/07/13/NAT_UPNP/","excerpt":"本文内容主要整理自胡军、周剑扬、师佳三位老师的论文《P2P 网络中 UPnP 穿越 NAT 的研究与实现》，并结合个人理解进行排版优化，仅供学习使用。","text":"本文内容主要整理自胡军、周剑扬、师佳三位老师的论文《P2P 网络中 UPnP 穿越 NAT 的研究与实现》，并结合个人理解进行排版优化，仅供学习使用。 0. 引言在 IPv4 的地址空间日益紧张的背景下，网络地址转换（NAT）技术被广泛应用以实现 IP 地址的重用。这虽然缓解了地址枯竭问题，但也给 P2P (Peer-to-Peer) 应用带来了巨大的通信障碍： 单向访问：位于 NAT 后面的内网节点（拥有私有 IP）可以主动访问公网，但公网节点无法主动访问内网节点。 服务限制：内网节点无法作为服务端为公网提供服务。 为了解决这些问题，学术界和工业界提出了多种 NAT 穿越方案，如服务器转发、反向连接以及 UDP 打洞等。本文将重点介绍一种利用 UPnP (Universal Plug and Play) 技术，通过其自动端口映射 (Auto-Port-Mapping) 功能来实现 NAT 穿越的方案。 1. UPnP 穿越 NAT 的原理与实现1.1 核心原理UPnP 穿越 NAT 的核心思想是：在 NAT 设备上动态地创建一个临时的”端口转发”规则。 具体流程如下： 内网的客户端程序通过 UPnP 协议，请求其所在的 NAT 设备（通常是路由器）将某个公网端口（如 8081）的所有流量，转发到该客户端的内网 IP 和指定端口（如 192.168.1.100:8080）。 客户端将这个成功映射的公网 IP 和端口（公网IP:8081）注册到一个公网服务器上。 当另一个 P2P 节点（例如节点 B）想要与这个客户端（节点 A）通信时，它从公网服务器获取节点 A 注册的公网地址信息。 节点 B 直接向节点 A 的 公网IP:8081 发送数据，NAT 设备会根据之前创建的映射规则，自动将数据转发给内网的节点 A，从而实现穿越。 1.2 自动端口映射的程序设计根据 UPnP 规范，实现自动端口映射主要涉及以下几个步骤： 发现 (Discovery) 客户端向 UPnP 的标准多播地址 239.255.255.250:1900 发送一个 M-SEARCH 查找请求。 网络中支持 UPnP 的 NAT 设备（路由器）会响应这个请求，并回复一个包含设备描述文件 URL 的消息。 描述 (Description) 客户端通过上一步获取的 URL，下载一个 XML 格式的设备描述文件。 解析这个 XML 文件，可以得到设备的详细信息，包括设备类型、服务列表以及最重要的——控制 URL。 控制 (Control) 客户端向第二步获取的控制 URL 发送一个遵循 SOAP 协议的 XML 控制消息。 通过发送不同的控制消息，可以实现端口映射的增加 (AddPortMapping)、删除 (DeletePortMapping) 或查询 (GetPortMapping) 等操作。 原论文作者将这些功能用 C++ 封装成了一个名为 upnpd.dll 的动态链接库，以便于客户端程序调用。 2. 系统两端的程序设计2.1 服务器端服务器在整个方案中扮演”中间人”的角色，其功能相对简单： 记录所有客户端登录时注册的公网端口映射信息。 处理客户端的登录、登出请求。 响应客户端获取其他在线用户列表的请求。这种方式极大地减轻了服务器的负担，避免了在服务器上直接转发所有 P2P 流量，节约了服务器资源和带宽。 2.2 客户端客户端的功能则相对复杂： 启动后，创建一个本地 Socket 并绑定到固定端口（如 8080）。 连接公网服务器，并从服务器获取经过 NAT 转换后的公网 IP 和端口（如 公网IP:8081）。 判断自身是否位于 NAT 之后。如果是，则调用 AddPortMapping 函数，请求路由器将公网端口 8081 映射到内网端口 8080。 通过 Getu 命令从服务器获取在线用户列表。 通过 Send 命令与其他客户端直接通信。 退出时，通过 Exit 命令调用 DeletePortMapping 函数，删除之前建立的端口映射。 3. 结论使用 UPnP 的自动端口映射功能进行 NAT 穿越，是一种高效且可靠的 P2P 通信方案。它适用于客户端位于单个 NAT 之后的多种网络情况。 此方案建立的端口映射通常是静态的，即使用户在一段时间内没有数据收发，映射关系也不会被 NAT 设备自动收回。这保证了 P2P 连接的稳定性和可靠性，是实现真正意义上直接通信的关键。 4. 参考文献 UPnP 论坛贡献成员. PnP 设备架构[S]. UPnP 标准组织委员会, 2000: 2-11. 林丽闽, 别红霞等译. 标准 C++宝典[M]. 北京: 电子工业出版社, 2001. Bryan Ford, Pyda Srisuresh, Dan Kegel. Peer-to-Peer(P2P) Communication Across Network Address Translators(NATs) [DB&#x2F;OL]. 2004-12-12. 李河, 王树明. P2P 网络中使用 UDP 穿越 NAT 的方法研究[J]. 吉林大学学报(信息科学版), 2003, 21(3). 刘扬, 董开坤, 刘杨, 迟乐军. 对等网络中穿越 NAT 解决方案的研究[J]. 计算机工程与设计, 2008, 6(29). P2P 网络中 UPnP 穿越 NAT 的研究与实现 胡 军 1 ， 周剑扬 2 ， 师 佳 1 （1. 厦门大学信息科学与技术学院自动化系， 厦门 361005； 2. 厦门大学信息科学与技术学院电子工程系，厦门 361005） 摘 要： NAT 的存在使得 P2P 通信存在极大的障碍, 因此穿透 NAT 已经成为 P2P 应用必须面对和解决的问题。 为此，介绍一种使用 UPnP 技术穿越 NAT 的技术，该方法主要是利用 UPnP 中自动端口映射技术来构建一种静态传输映射来实现,并给出采用简单、稳定而且易于实现的 UPnP 中自动端口映射技术穿透 NAT 的实例。 关键词： NAT； UPnP； 自动端口映射； 静态传输映射 引 言 在 IPv4 的地址空间中， 为了解决网络资源的问题，常常使用网络地址转换来实现地址的重用；这样就产生了我们通常所说的内网 IP （处在 NAT 后面的 IP）， 这样形成的网络架构给网络节点的通信带来了问题：① 内网的 IP 不能被外网识别，外网的节点不能主动的访问内网的节点； ② 内网的节点可以访问公网，但是不能作为服务端为公网提供服务。 针对这种情况， 人们提出了一些穿越 NAT 来应用 P2P 技术的解决方案，常见的有服务器转发技术、反向连接技术以及 UDP 打洞技术， 然而这三种技术都能实现 NAT 的穿越。 UPnP 穿越 NAT 的原理与实现 UPnP 穿越 NAT 的实现原理如下：首先在内网节点（客户端）分别通过软件程序在各自的 NAT 中建立一个自动端口映射信息，然后由内网节点（客户端）分别向一个公网的节点（服务器）注册自己的端口映射信息，并保存在服务器上；当内网节点 A 想与当内网节点 B 进行通信时，只需要通过在公网的节点（服务 现 器）上获取对方的端口映射信息，并向对方的映射端 代 口发送信息就能实现 NAT 的穿越。 计 1.1 自动端口映射部分的程序设计 算 按照 UPnP 的相关协议和规范，UPnP 的工作过 机 程包括寻址、发现、描述、控制、触发和展示 6 个部分。 总 （ 设备首先通过寻址来获得一个网络地址。 第 然后， 第一步是发现， 控制点在网上寻找 UPnP 三 一 三 收稿日期：2009-05-07 修稿日期：2009-05-18 \u000e 设备，而设备向网络中的控制点宣告其服务。 对于自动端口映射来说就是发现支持 UPnP 功能的路由器。发现的过程如下： 首先是使用数据报套接字向 239.255.255.250：1900，发送一条多播请求，如果网络中存在一个 UPnP 设备的话，设备必须向发送查找请求的多播通道的源 IP 地址和端口发送相应信息；因此，我们可以从 239.255.255.250：1900 这个地址收到相应消息并可以获得设备描述 URL； 第二步是描述，在第一步中我们能够获得设备描 述 URL，在第二步中通过这个 URL 下载一个 XML 的文件，并从其中找到有关设备的类型、服务类型、控制 URL 和事件触发等信息； 第三步是控制，由第二步获得的控制 URL，通过向其发送控制消息（XML 描述）来实现控制功能，在此，我们主要是实现查看、增加、删除自动端口映射； 第四步和第五步分别是触发和展示，在我们实现自动端口映射过程中没有用到。 根据以上思路，用 C++语言实现了自动端口映射部分的程序，并将查看、增加、删除自动端口映射的功能封装成一个 upnpd.dll 的一个动态连接库， 主要包括 addportmapping、delportmapping 和 getportmapping 函数来建立、删除和获得端口映射关系。 服务器端程序设计 服务器端功能主要是记录客户端的端口映射信息，读取客户端登录和登出的消息，以及转发客户端获取客户列表的申请等。这样大大地减轻了服务器的工作量， 不会像服务器转发技术穿越 NAT 那样给服务器很大的工作量并将全面依赖消耗服务器的资源 期 作者简介： 胡军（1984-），男，四川蓬安人，硕士，研究方向为嵌入式系统及计算机网络控制 ） 貋貙貥 \u000e M O D E R N C OM P U T E R 2009.8 Socket ! “ 和性能以及网络带宽。 图 1 服务器端程序流程图 客户端程序设计 客户端的主要功能如下： 首先创建一个本地 Socket 并绑定到本机的一个固定端口（例如 8080），连接服务器， 同时请求服务器并获得经过 NAT 转换后 \u000e 的端口号（例如 8081），判断本机的 IP 是否是在局域网内， 如果是则调用增加自动端口映射函数 ad- dportmapping（8081，”TCP”或者”UDP”,8080）来建立自动端口映射；如果本机是公网的固定 IP 则不用进行自动端口映射。 然后通过 Getu 命令获得客户登录的列表，通过 Send 命令就可以实现两个不同客户端之间的通信了，Exit 命令删除添加的映射端口并退出程序。 应用实例 考虑如下所示的网络结构， 实例采用 UDP 进行连接（如图 3）。 首先在公网的固定 IP 上运行服务器端的程序，并记录其固定 IP； 然后在两个不同的 NAT 后面运行客户端程序，输入服务器 IP 和用户名，登录成功后会返回登录的用户信息并进行判断是否增加自动端口映射， 如果在 NAT 后面会增加自动端口映射并提示增加的端口映射号， 最后等待用户输入命令，Getu、 Send、Exit 分别用于获取用户列表、 向指定用户发送信息和退出程序。 图 2 客户端程序流程图 \u000e M O D E R N C OM 第三一三期 ） 貦貙貋 图 3 实例网络结构 其运行程序结果如下： \u000e 由以上的运行结果可以看出，P2P 的通信成功的实现了。 结 语 本文实现了使用 UPnP 中的自动端口映射功能进行 NAT 的穿越， 此方案能够适用于不同客户端位于单个 NAT 后面的多种情况， 同时本方案所实现的 UPnP 对 NAT 的传输映射是静态的，也就是说经过一段时间后，如果客户端不再发送或接收数据，这种映射关系不会自动解除，端口号也不会被 NAT 收回，这样保证了能够建立稳定和可靠的的端口映射关系，实现了 P2P 网络中的直接通信。 参考文献 UPnP 论坛贡献成员. PnP 设备架构[S]. UPnP 标准组织委员会，2000：2-11 林丽闽，别红霞等译. 标准 C++宝典[M]. 北京：电子工业出版社，2001 Bryan Ford， Pyda Srisuresh，Dan Kegel. Peer-to-Peer(P2P) Communication Across Network Address Translators(NATs) [DB&#x2F;OL]. http://www.brynosaurus.com/pub/net/internet- drafts&#x2F;draft-ford-midcom-p2p-03.txt，2004-12-12 李河,王树明. P2P 网络中使用 UDP 穿越 NAT 的方法研 究[J]. 吉林大学学报(信息科学版), 2003,21(3) 刘扬，董开坤，刘杨，迟乐军. 对等网络中穿越 NAT 解决方案的研究[J]. 计算机工程与设计，2008，6(29) 图 4 用户 hujun 图 5 用户 xmu Research and Implementation of Traversing NAT Using UPnP under P2P Network Environment HU Jun1 ， ZHOU Jian-yang2 ， SHI Jia1 现代计算机 （总 第三一三期 ） 貋貙貧 \u000e （1.Department of Automation, Xiamen University, Xiamen 361005; \\2. Department of Electronic Engineering, Xiamen University, Xiamen 361005） Abstract： The existing of NAT proves a great obstacle to the P2P communication, so how to traverse NAT has become a problem to be faced and solved in the application of the P2P. Therefore, introduces a technique of the using UPnP to traverse NAT. This method mainly uses the au- to-port-mapping in the UPnP employed to build a static-transmitting-mapping to achieve the traversing. It also gives a good example to show how to use the auto-port-mapping technique, which is the simpler, stabler and more achievable in the UPnP to traverse NAT. Keywords： NAT; UPnP; Auto-Port-Mapping; Static-Transmitting-Mapping M O D E R N C OM P U T E R 2009.8","categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"http://example.com/tags/%E8%AE%A1%E7%BD%91/"},{"name":"P2P","slug":"P2P","permalink":"http://example.com/tags/P2P/"},{"name":"NAT","slug":"NAT","permalink":"http://example.com/tags/NAT/"}]},{"title":"MySql 全方位学习笔记","slug":"MySql","date":"2023-06-13T13:56:14.000Z","updated":"2025-06-27T17:24:24.082Z","comments":true,"path":"2023/06/13/MySql/","link":"","permalink":"http://example.com/2023/06/13/MySql/","excerpt":"MySql 学习大全","text":"MySql 学习大全 MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面是最好的 RDBMS(Relational Database Management System) 应用软件之一。 什么是数据库？数据库（Database）是按照特定数据结构来组织、存储和管理数据的仓库。 虽然我们可以将数据存储在普通文件中，但当数据量庞大时，在文件中进行读写、查找和管理的效率会变得非常低下。 因此，现代应用普遍使用关系型数据库管理系统（RDBMS）来高效地存储和管理海量数据。所谓的关系型数据库，是建立在关系模型基础上的数据库，它借助于集合代数等数学概念和方法来处理数据。 RDBMS 的特点 **数据以表格的形式出现 (Table)**：这是关系型数据库的核心。 **每行为一条记录 (Row&#x2F;Record)**：代表一个实体的一组相关数据。 **每列为一个字段 (Column&#x2F;Field)**：包含同一种类型的数据。 许多的行和列组成一张**表 (Table)**。 若干的表组成一个**数据库 (Database)**。 RDBMS 核心术语 数据库 (Database): 是一些关联表的集合。 数据表 (Table): 表是数据的矩阵，看起来像一个简单的电子表格。 列 (Column): 一列(数据元素) 包含了相同类型的数据, 例如邮政编码。 行 (Row): 一行（也称元组或记录）是一组相关的数据，例如一条用户信息。 主键 (Primary Key): 表中的唯一标识符。一个数据表中只能包含一个主键，用于快速查询和保证数据唯一性。 外键 (Foreign Key): 用于在一个表中引用另一个表中的记录，以建立两个表之间的关联。 复合键 (Composite Key): 将多个列组合起来作为一个主键或唯一索引。 索引 (Index): 一种特殊的数据结构，用于快速访问数据库表中的特定信息，类似于书籍的目录，可以极大地提高查询速度。 参照完整性 (Referential Integrity): 要求关系中不允许引用不存在的实体。这是保证数据一致性的重要约束。 MySql 安装指南 (Windows)1. 下载 MySql访问官方下载地址: https://dev.mysql.com/downloads/mysql/ 2. 解压缩将下载的压缩包解压到一个合适的目录，注意：路径中不能包含中文或空格。 3. 配置环境变量将 MySQL 的 bin 目录路径（例如 D:\\dev\\mysql-8.0.27-winx64\\bin）添加到系统的 Path 环境变量中。 4. 添加配置文件 my.ini【选做】 此步骤可选，如果不创建，MySql 会使用系统默认配置。 在 MySQL 的根目录中，手动创建一个名为 my.ini 的文件。 将以下内容复制到 my.ini 中，并务必修改 basedir 和 datadir 为你自己的实际路径。 1234567891011121314151617181920212223242526[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\\\dev\\\\mysql-8.0.27-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\\\dev\\\\mysql-8.0.27-winx64\\\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用&quot;mysql_native_password&quot;插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 5. 初始化数据库以管理员身份运行命令提示符 (CMD)。 在 CMD 中执行以下命令，MySQL 会进行初始化并生成一个临时密码，请务必复制并保存好这个密码。 1mysqld --initialize --console 6. 安装 MySql 服务继续在管理员 CMD 中执行以下命令来安装 MySQL 服务： 1mysqld --install 7. 启动服务使用以下命令启动 MySQL 服务： 1net start mysql 8. 登录 MySql 并修改密码 在 CMD 中，输入以下命令并按回车： 1mysql -uroot -p 提示 Enter password: 后，粘贴你之前保存的临时密码，然后按回车。 登录成功后，立即执行以下 SQL 语句来修改为您自己的新密码（例如 12345678）： 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;12345678&#x27;; 9. 卸载 MySql（备用）如果需要卸载 MySQL，请按以下步骤操作： 停止服务 (管理员 CMD):1net stop mysql 移除服务 (管理员 CMD):1mysqld --remove 手动删除 MySQL 的安装文件夹。 可视化连接工具：Navicat为了更方便地管理数据库，我们可以使用图形化界面工具。Navicat 是其中非常流行的一款。 下载与安装 官网下载: https://www.navicat.com.cn/download/navicat-premium 安装: 下载后双击 .exe 文件，按提示进行可视化安装即可。 新建连接 在 Navicat 中，点击”连接” -&gt; “MySQL”，然后输入连接名、主机（localhost）、端口（3306）、用户名（root）和你刚才设置的新密码，点击”连接测试”，成功后保存即可。 SQL 入门数据库、表、数据的关系 数据库 (Database): 存储和管理数据的仓库，一个库可以包含多个数据表。 数据表 (Table): 数据库中最重要的组成部分，由行和列组成，类似 Excel 表格。 数据 (Data): 表中存储的一行行具体信息，是我们真正要管理的内容。 SQL 语言介绍 什么是 SQL? Structured Query Language，即结构化查询语言。 它是操作所有关系型数据库的国际标准。不同的数据库可能会在标准 SQL 的基础上增加一些自己特有的语法，我们称之为”方言”。 SQL 通用语法 SQL 语句可以单行或多行书写，通常以分号 (;) 结尾。 可使用空格和缩进来增强语句的可读性。 SQL 语句不区分大小写，但业界约定关键字使用大写，表名和列名使用小写。 注释: 单行注释: -- 注释内容 或 # 注释内容 (MySQL 特有) 多行注释: /* 注释内容 */","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"力扣1031","slug":"力扣1031","date":"2023-04-26T06:15:00.000Z","updated":"2023-04-26T06:34:41.535Z","comments":true,"path":"2023/04/26/力扣1031/","link":"","permalink":"http://example.com/2023/04/26/%E5%8A%9B%E6%89%A31031/","excerpt":"#两个非重叠子数组的最大和","text":"#两个非重叠子数组的最大和 1031. 两个非重叠子数组的最大和 - 力扣（LeetCode）前缀和+动态规划：首先用前缀数组可以快速求出数组中两点中的元素的和，首先应该想象到找到first的元素的和，去遍历second的和找到最大和时间复杂度O(n^2),应该不难想到。 用动态规划去解决问题时，遍历一遍找到最大一个first的值，很简单就想到用一个 sum&#x3D;max(sum,s[i]-s[i-first]); 解决问题， 但是问题是求两端的和 有个方法很难想到，我反正是想不到，首先first与second的大小不同导致不清楚答案是谁在前谁在后 所以分开考虑假如second在前，则有在每次找first的最大时刻后面更新答案， sum &#x3D; max(sum,s[i-first]-s[i-first-second]); ans &#x3D; max(ans,sum+s[i]-s[i-first]); 同理另一种情况也是一样最终得出答案. 1234567891011121314151617181920212223class Solution &#123;public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; nums, int firstLen, int secondLen) &#123; int s[1001],n = nums.size(); s[0]=0; for(int i=1,sum=0;i&lt;=n;i++) &#123; sum+=nums[i-1]; s[i] = sum; &#125; int sum1=0,sum2=0,ans1=0,ans2=0; for(int i=firstLen+secondLen;i&lt;=n;i++) &#123; sum1 = max(sum1,s[i-secondLen]-s[i-secondLen-firstLen]); ans1 = max(ans1,sum1+s[i]-s[i-secondLen]); sum2 = max(sum2,s[i-firstLen]-s[i-firstLen-secondLen]); ans2 = max(ans2,sum2+s[i]-s[i-firstLen]); &#125; return max(ans1,ans2); &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"力扣1043和368","slug":"力扣1043和368","date":"2023-04-19T02:23:00.000Z","updated":"2023-04-19T12:34:42.457Z","comments":true,"path":"2023/04/19/力扣1043和368/","link":"","permalink":"http://example.com/2023/04/19/%E5%8A%9B%E6%89%A31043%E5%92%8C368/","excerpt":"#动态规划两道题","text":"#动态规划两道题 1043. 分隔数组以得到最大和 - 力扣（LeetCode）方法一（过不了）：树状数组＋dfs用dfs暴力搜索时间复杂度为指数型，用树状数组优化，但还是指数型 介绍一下树状数组： 【五分钟丝滑动画讲解 | 树状数组】 https://www.bilibili.com/video/BV1ce411u7qP/?share_source=copy_web&amp;vd_source=c9899d0504fa271ca6db5ef82d1a6bbb 树状数组的作用， 1.以O(logN)找到一个下表的 i 到 j 的和 2.以O(logN)更新一个下表的数字 3.空间复杂度为O(N) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;int&gt; tr; int lowerBit(int i) &#123; return (i&amp;-i); &#125; void add(int i,int z) &#123; for(;i&lt;tr.size();i+=lowerBit(i)) &#123; tr[i]+=z; &#125; &#125; int query(int i) &#123; int res=0; for(;i&gt;0;i-=lowerBit(i)) &#123; res+=tr[i]; &#125; return res; &#125;//树状数组的定义 int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; tr = vector&lt;int&gt;(arr.size()+1,0); int ma=0; function&lt;void(int)&gt; dfs = [&amp;](int dex)&#123; if(dex==arr.size())//下表超出，找到总和 &#123; ma = max(ma,query(tr.size()-1)); return; &#125; int res=0; for(int i=dex;i&lt;arr.size()&amp;&amp;i-dex&lt;k;i++) &#123; res = max(res,arr[i]); for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,res); &#125; dfs(i+1);//更新tr，递归后删除更新的数值 for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,-res); &#125; &#125; &#125;; dfs(0); return ma; &#125; &#125;; 方法二：dp简单分析一下找到数组的最大值，就是找到n的位置于n的前k项进行组合找到最大值 dp中储存的就是当前下表大小的数组的和最大值 推出动态方程 dp[i] &#x3D; max(dp[i],dp[j]+valmax*(i-j)); 12345678910111213141516171819class Solution &#123;public: int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; pd(arr.size()+1,0); //多一个是为了让以dp[0]=0开头，让下表i存的是前i项之和包括i for(int i=1;i&lt;arr.size()+1;i++) &#123; int maxv=arr[i-1]; for(int j=i-1;j&gt;=0&amp;&amp;i-j&lt;=k;j--) &#123; pd[i] = max(pd[i],pd[j]+(i-j)*maxv); if(j&gt;0) maxv = max(maxv,arr[j-1]); &#125; &#125; return pd[arr.size()]; &#125; &#125;; 时间复杂度O(NK) 空间是O(N) 368. 最大整除子集 - 力扣（LeetCode）dp+数学（简单的数学）：数学方面就是：在一个集合中使各个元素的最大公因数，最小公倍数是两个数本身 也就是说一个数能被另一个数整除 一个大于集合的所有数判断是否能被集合中所有元素整除，只需要判断能被集合中最大的数整除 所以先对nums排序 dp方程为dp[i] &#x3D; max(dp[j]+1); 保存最大的值，从最大的值开始往前找，找到连续可行的子序列 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;int&gt;ans; vector&lt;pair&lt;int,int&gt;&gt; mp(nums.size(),&#123;0,-1&#125;); int ma=-1,biao=0; for(int i=0;i&lt;nums.size();i++) &#123; for(int j=i-1;j&gt;=0;j--) &#123; if(nums[i]%nums[j]==0&amp;&amp;mp[i].first&lt;mp[j].first) &#123; mp[i].first = mp[j].first; mp[i].second = j; &#125; &#125; mp[i].first++; if(ma&lt;mp[i].first) &#123; ma = mp[i].first; biao = i; &#125; &#125; while(biao&gt;=0) &#123; ans.push_back(nums[biao]); biao = mp[biao].second; &#125; return ans; &#125;&#125;; 时间复杂度O(N^2) 空间复杂度O(2N)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"wallhaven爬虫","slug":"wallhaven爬虫","date":"2022-12-04T16:19:14.000Z","updated":"2025-06-27T17:06:17.498Z","comments":true,"path":"2022/12/05/wallhaven爬虫/","link":"","permalink":"http://example.com/2022/12/05/wallhaven%E7%88%AC%E8%99%AB/","excerpt":"py爬取壁纸（setu）wallhaven网站爬取","text":"py爬取壁纸（setu）wallhaven网站爬取 刚开始爬的时候一切顺利，但最后遇到了反爬虫机制，就是必须要登录，否则无法显示一些色图。 首先想到的就是 py 模拟登录，这里说两种解法： 在 post 请求中把账号，密码输入，一般都不会成功，因为会有 JS 加密。这里可以解密，但具体我也不了解就不往下说了。 可行且简单的方法，用 Cookie 绕过去。先说一下 Cookie 的概念：在客户端对服务器发送请求，服务器会产生客户端的记录，来得知客户端之前做过什么。就比如你登录了 Bilibili，关了之后再进入就免登录了，这之间就是 Cookie 的功劳，让服务器记得你。回归正题，模拟登录就是首先你要登录这个网站，再记录 Cookie，爬取的 headers 填上 Cookie，然后就进入登录后的界面了，就可以下载图片了。 12345678910111213141516171819202122232425262728293031323334353637383940import requestsimport parselimport osfor shuzi in range(1,75): print(f&quot;正在下载第&#123;shuzi&#125;页&quot;) url = &#x27;https://wallhaven.cc/hot?page=&#x27; # 头请求就不展示了 # ！！！这个网站的反爬虫机制就是登录，用cookie绕过登录----&gt; headers = &#123; &#x27;user-agent&#x27;: &#x27;your-user-agent-string&#x27;, &#x27;cookie&#x27; : &#x27;your-cookie-string&#x27; &#125; # 此处的 cook 变量未定义，在实际运行时需要替换为您的 cookie 字典 req = requests.get(url+str(shuzi),headers=headers) print(url+str(shuzi)) sele = parsel.Selector(req.text) lis = sele.css(&#x27;.preview&#x27;) for li in lis: pic_url = li.css(&#x27;.preview ::attr(href)&#x27;).get() print(pic_url) pos = requests.get(pic_url,headers=headers,verify=False) pic_sele = parsel.Selector(pos.text) pic_lis = pic_sele.xpath(&#x27;//div[@class=&quot;scrollbox&quot;]//img/@src&#x27;).getall() print(pic_lis) for pic_urll in pic_lis: pic = requests.get(pic_urll,headers=headers,verify=False).content pic_name = pic_urll.split(&#x27;/&#x27;)[-1] if not os.path.exists(f&#x27;..//&#123;pic_name&#125;&#x27;): with open(f&#x27;..//&#123;pic_name&#125;&#x27;,&#x27;wb&#x27;) as f: f.write(pic) print(&#x27; 完成图片&#x27;+pic_name) else: print(&#x27; 已存在&#x27;+pic_name) 图片壁纸需要自取下面是wallhaven网站热门壁纸。果然，某些图片是第一生产力。因为不能上传太多，就随便传了几张，可以尝试自己爬取哦。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"小齐的第一篇博客","slug":"齐振豪的第一篇博客","date":"2022-12-01T10:13:23.000Z","updated":"2025-06-27T17:48:15.401Z","comments":true,"path":"2022/12/01/齐振豪的第一篇博客/","link":"","permalink":"http://example.com/2022/12/01/%E9%BD%90%E6%8C%AF%E8%B1%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"进来听听歌","text":"进来听听歌 恭喜你，成功打开了我的第一篇博客！ 希望这首歌能给你带来好心情。祝你的人生，一路顺风！ 从这里开始，记录成长，分享生活。加油！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}]