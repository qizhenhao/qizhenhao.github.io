[{"title":"与德利和树上课交流有感","slug":"与德利和树上课交流有感","date":"2023-11-24T09:43:46.044Z","updated":"2023-11-24T12:48:08.634Z","comments":true,"path":"2023/11/24/与德利和树上课交流有感/","link":"","permalink":"http://example.com/2023/11/24/%E4%B8%8E%E5%BE%B7%E5%88%A9%E5%92%8C%E6%A0%91%E4%B8%8A%E8%AF%BE%E4%BA%A4%E6%B5%81%E6%9C%89%E6%84%9F/","excerpt":"本次主要对生活与爱情进行探讨","text":"本次主要对生活与爱情进行探讨 ​ 时间还长，放松一下，放首音乐边听边看。 ​ 今天上课，我的两位挚友没来，思强与腾浩，不知道他俩干啥去了，大概是偷懒了吧，恰好最后有德利与树在后面，为了不让德利太卷，我与树帮助德利战胜了他的学习的欲望。 生活篇 ​ 让后我们就开始了对生活的探讨，具体的也就是对当下的前途，工作进行了一次探讨，确实，我回想到前两年，大一大二真的是历历在目，这两年确实经历了不少，成长了不少，从我刚入学开始说起，在选学校的时候，我与我姐去了西亚斯看看学校怎么样，走的时候遇到了改变整个我大学生活的学长，他很热情的给我介绍学校，我当时非常腼腆，走的时候，我姐非让我加学长的微信，虽然没什么，但对我来说这却是成长路上的第一道关。后来到了工作室招人的时候，学长联系我给我推荐起点工作室，我只听到要求严格，其他的便没在意，长话短说，学到了该分方向的时候，我本想选java，学长劝我学c，说实话当时我根本不在乎选什么，因为我不懂，在这里我打断我自己一下，分析一下两个方向的利弊，我是人工智能的如果结合着专业的话选java更好，如果选了java可能现在就被老师带着去打比赛了，还可能争取一下奖学金，选c的话就是学习一些底层，底层学了什么就能做了，游戏开发，app开发等等，但毕竟学的东西多而且难，离找工作差距还很大，我不知道要不要考研，我不想去赌，考不上工作也找不到，就更难了，我放弃考研了，现在多学一些技术，为了好找工作，我现在可算是看清了，选java路是走的顺一点，但如果着两个选择再摆到我面前，我还是会选C。 ​ 回到这节课上，我感概了一下自己的经历，“光明前途我看不见，道路曲折我走不完，唉”，这时，德利也说出了自己的经历，在大二的时候，有三个事集中到一起，算法比赛，计算机证书，4级英语考试，但全部挂，但中间却努力了不少，甚至说努力已经超过很多人了，这时候正常人都会说是方法没用对，但我没这样说，我明白方法是天赋的一部分，有些东西追溯到本源就是命，他是在忍不住了，找到马老师哭了，男儿有泪不轻弹，只是未到伤心处。是的失败是贯彻生命的，树这样说道，我想起了之前的比赛经历，我总结出了一句对我终身受益的一句话，“遇到事情首先要做的就是，放平心态，坦然面对，一挥手，无所谓。”，最后两句并不是让你与世无争，而是告诉你，有些东西，过去了就该放下了，潇潇洒洒，一挥手，无所谓。 爱情篇 ​ 德利提出了他想找对象，我当时就想到自己对这种东西的理解，所以这一篇就讲讲我对爱情的理解。 ​ 首先说结论爱情不是桃花源，不是温柔乡，所谓爱情不过是交换三张牌，三张牌分别是，性价值，金钱价值，情绪价值。上高中或者初中的时候，性价值是排第一的，性价值就是人原始的欲望，不要小看性价值，这就是人繁殖的关键，我们这里所说的性价值就是颜值，身高，身材等，一些外表的东西，其次就是情绪价值，这种价值，直接一点说明就是你能为对象提供多少好的情绪，清洗多少坏的情绪，而有情绪价值的人往往是情商高的，或者甘愿为另一半付出的，排到最后的应该就是金钱价值，这种价值，就是钱，社会地位，能带动另一半过上好的生活。上了大学后，三种价值的地位发生了改变，金钱价值越来越体现出来，因为大家毕业了就要面对生活的柴米油盐，大家都意识到了金钱价值的重要性。出来学校，到了社会，那这三种价值，不用我多说，怎么排序大家清楚。 ​ 但是我也发现了情绪价值，可能是最接近爱情的东西了，但这种价值始终没排上号，我想到，这种价值终会有时候排到第一的，当人们的容颜被岁月抹去，激情褪去，当一个人的经历足以让自己的思想从金钱与地位的禁锢中得到解脱。没错大概就是40岁左右的时候，情绪价值就是最重要的。 ​ 三种价值讲完了，在回到现实，电视剧里的青春爱情❤，终究是是少数，大多都是普通人，外貌不出众，没有能力提供金钱价值，情绪价值也常常被说成舔狗，所以当想谈恋爱的时候想想你想要什么，无非就是想要别人提供给你的三种价值，回归主题，当你想让别人给你提供价值的时候，想想自己有什么价值，因为爱情无非就是一场交易。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"NAT与UPNP技术","slug":"NAT_UPNP","date":"2023-07-13T13:19:14.000Z","updated":"2023-07-13T14:04:08.530Z","comments":true,"path":"2023/07/13/NAT_UPNP/","link":"","permalink":"http://example.com/2023/07/13/NAT_UPNP/","excerpt":"大佬的一篇论文，自用","text":"大佬的一篇论文，自用 实践与经验 P2P 网络中 UPnP 穿越 NAT 的研究与实现 胡 军 1 ， 周剑扬 2 ， 师 佳 1 （1. 厦门大学信息科学与技术学院自动化系， 厦门 361005； 2. 厦门大学信息科学与技术学院电子工程系，厦门 361005） 摘 要： NAT 的存在使得 P2P 通信存在极大的障碍, 因此穿透 NAT 已经成为 P2P 应用必须面对和解决的问题。 为此，介绍一种使用 UPnP 技术穿越 NAT 的技术，该方法主要是利用 UPnP 中自动端口映射技术来构建一种静态传输映射来实现,并给出采用简单、稳定而且易于实现的 UPnP 中自动端口映射技术穿透 NAT 的实例。 关键词： NAT； UPnP； 自动端口映射； 静态传输映射 引 言 在 IPv4 的地址空间中， 为了解决网络资源的问题，常常使用网络地址转换来实现地址的重用；这样就产生了我们通常所说的内网 IP （处在 NAT 后面的 IP）， 这样形成的网络架构给网络节点的通信带来了问题：① 内网的 IP 不能被外网识别，外网的节点不能主动的访问内网的节点； ② 内网的节点可以访问公网，但是不能作为服务端为公网提供服务。 针对这种情况， 人们提出了一些穿越 NAT 来应用 P2P 技术的解决方案，常见的有服务器转发技术、反向连接技术以及 UDP 打洞技术， 然而这三种技术都能实现 NAT 的穿越。 UPnP 穿越 NAT 的原理与实现 UPnP 穿越 NAT 的实现原理如下：首先在内网节点（客户端）分别通过软件程序在各自的 NAT 中建立一个自动端口映射信息，然后由内网节点（客户端）分别向一个公网的节点（服务器）注册自己的端口映射信息，并保存在服务器上；当内网节点 A 想与当内网节点 B 进行通信时，只需要通过在公网的节点（服务 现 器）上获取对方的端口映射信息，并向对方的映射端 代 口发送信息就能实现 NAT 的穿越。 计 1.1 自动端口映射部分的程序设计 算 按照 UPnP 的相关协议和规范，UPnP 的工作过 机 程包括寻址、发现、描述、控制、触发和展示 6 个部分。 总 （ 设备首先通过寻址来获得一个网络地址。 第 然后， 第一步是发现， 控制点在网上寻找 UPnP 三 一 三 收稿日期：2009-05-07 修稿日期：2009-05-18 \u000e 设备，而设备向网络中的控制点宣告其服务。 对于自动端口映射来说就是发现支持 UPnP 功能的路由器。发现的过程如下： 首先是使用数据报套接字向 239.255.255.250：1900，发送一条多播请求，如果网络中存在一个 UPnP 设备的话，设备必须向发送查找请求的多播通道的源 IP 地址和端口发送相应信息；因此，我们可以从 239.255.255.250：1900 这个地址收到相应消息并可以获得设备描述 URL； 第二步是描述，在第一步中我们能够获得设备描 述 URL，在第二步中通过这个 URL 下载一个 XML 的文件，并从其中找到有关设备的类型、服务类型、控制 URL 和事件触发等信息； 第三步是控制，由第二步获得的控制 URL，通过向其发送控制消息（XML 描述）来实现控制功能，在此，我们主要是实现查看、增加、删除自动端口映射； 第四步和第五步分别是触发和展示，在我们实现自动端口映射过程中没有用到。 根据以上思路，用 C++语言实现了自动端口映射部分的程序，并将查看、增加、删除自动端口映射的功能封装成一个 upnpd.dll 的一个动态连接库， 主要包括 addportmapping、delportmapping 和 getportmapping 函数来建立、删除和获得端口映射关系。 服务器端程序设计 服务器端功能主要是记录客户端的端口映射信息，读取客户端登录和登出的消息，以及转发客户端获取客户列表的申请等。这样大大地减轻了服务器的工作量， 不会像服务器转发技术穿越 NAT 那样给服务器很大的工作量并将全面依赖消耗服务器的资源 期 作者简介： 胡军（1984-），男，四川蓬安人，硕士，研究方向为嵌入式系统及计算机网络控制 ） 貋貙貥 \u000e M O D E R N C OM P U T E R 2009.8 Socket ! “ 和性能以及网络带宽。 图 1 服务器端程序流程图 客户端程序设计 客户端的主要功能如下： 首先创建一个本地 Socket 并绑定到本机的一个固定端口（例如 8080），连接服务器， 同时请求服务器并获得经过 NAT 转换后 \u000e 的端口号（例如 8081），判断本机的 IP 是否是在局域网内， 如果是则调用增加自动端口映射函数 ad- dportmapping（8081，“TCP”或者“UDP”,8080）来建立自动端口映射；如果本机是公网的固定 IP 则不用进行自动端口映射。 然后通过 Getu 命令获得客户登录的列表，通过 Send 命令就可以实现两个不同客户端之间的通信了，Exit 命令删除添加的映射端口并退出程序。 应用实例 考虑如下所示的网络结构， 实例采用 UDP 进行连接（如图 3）。 首先在公网的固定 IP 上运行服务器端的程序，并记录其固定 IP； 然后在两个不同的 NAT 后面运行客户端程序，输入服务器 IP 和用户名，登录成功后会返回登录的用户信息并进行判断是否增加自动端口映射， 如果在 NAT 后面会增加自动端口映射并提示增加的端口映射号， 最后等待用户输入命令，Getu、 Send、Exit 分别用于获取用户列表、 向指定用户发送信息和退出程序。 图 2 客户端程序流程图 \u000e M O D E R N C OM P U T E R 2009．8 \u000e 现代计算机 JJf:it Socket IP ffl]&#x3D;1 1 0234IP5 0 678”9:+;&lt;&#x3D; “&gt; +; Getu% &amp; ]&#x3D;1’()* Send%&amp;]&#x3D;1 +,- )* Exit% B CD)* ff� f�Ill[ ff f�Ill[ !ff�ffl]&#x3D;1 “ f�Ill[ CD.&#x2F; 0 1 ?@A7”&lt;&#x3D;+; 0 ?@A7”&lt;&#x3D;+; 1 .&#x2F; #$ （总 第三一三期 ） 貦貙貋 图 3 实例网络结构 其运行程序结果如下： \u000e 由以上的运行结果可以看出，P2P 的通信成功的实现了。 结 语 本文实现了使用 UPnP 中的自动端口映射功能进行 NAT 的穿越， 此方案能够适用于不同客户端位于单个 NAT 后面的多种情况， 同时本方案所实现的 UPnP 对 NAT 的传输映射是静态的，也就是说经过一段时间后，如果客户端不再发送或接收数据，这种映射关系不会自动解除，端口号也不会被 NAT 收回，这样保证了能够建立稳定和可靠的的端口映射关系，实现了 P2P 网络中的直接通信。 参考文献 UPnP 论坛贡献成员. PnP 设备架构[S]. UPnP 标准组织委员会，2000：2-11 林丽闽，别红霞等译. 标准 C++宝典[M]. 北京：电子工业出版社，2001 Bryan Ford， Pyda Srisuresh，Dan Kegel. Peer-to-Peer(P2P) Communication Across Network Address Translators(NATs) [DB&#x2F;OL]. http://www.brynosaurus.com/pub/net/internet- drafts&#x2F;draft-ford-midcom-p2p-03.txt，2004-12-12 李河,王树明. P2P 网络中使用 UDP 穿越 NAT 的方法研 究[J]. 吉林大学学报(信息科学版), 2003,21(3) 刘扬，董开坤，刘杨，迟乐军. 对等网络中穿越 NAT 解决方案的研究[J]. 计算机工程与设计，2008，6(29) 图 4 用户 hujun 图 5 用户 xmu Research and Implementation of Traversing NAT Using UPnP under P2P Network Environment HU Jun1 ， ZHOU Jian-yang2 ， SHI Jia1 现代计算机 （总 第三一三期 ） 貋貙貧 \u000e （1.Department of Automation, Xiamen University, Xiamen 361005; \\2. Department of Electronic Engineering, Xiamen University, Xiamen 361005） Abstract： The existing of NAT proves a great obstacle to the P2P communication, so how to traverse NAT has become a problem to be faced and solved in the application of the P2P. Therefore, introduces a technique of the using UPnP to traverse NAT. This method mainly uses the au- to-port-mapping in the UPnP employed to build a static-transmitting-mapping to achieve the traversing. It also gives a good example to show how to use the auto-port-mapping technique, which is the simpler, stabler and more achievable in the UPnP to traverse NAT. Keywords： NAT; UPnP; Auto-Port-Mapping; Static-Transmitting-Mapping M O D E R N C OM P U T E R 2009.8","categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"http://example.com/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"MySql介绍","slug":"MySql","date":"2023-06-13T13:56:14.000Z","updated":"2023-07-13T14:09:31.856Z","comments":true,"path":"2023/06/13/MySql/","link":"","permalink":"http://example.com/2023/06/13/MySql/","excerpt":"Mysql 大全","text":"Mysql 大全 MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。 什么是数据库数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。 我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。 所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS 即关系数据库管理系统(Relational Database Management System)的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成 database RDBMS 术语在我们开始学习 MySQL 数据库前，让我们先了解下 RDBMS 的一些术语： 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。 行：一行（&#x3D;元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格: MySQL 数据库MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，目前隶属于 Oracle 旗下产品。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对 PHP 有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为 8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 MySql 安装下载 MySqlhttps://dev.mysql.com/downloads/mysql/ 解压缩解压目录：不能有中文、空格 配置环境变量 添加 my.ini【选做】 本段内容可以选择不做，MySql 会使用系统默认配置 在 mysql 目录中，手动创建my.ini文件 复制以下内容到 my.ini，注意修改 basedir 和 datadir 的具体目录。如果要在一台电脑上安装多个 mysql 服务，则需要修改端口号 123456789101112131415161718192021222324252627[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\\\dev\\\\mysql-8.0.27-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\\\dev\\\\mysql-8.0.27-winx64\\\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 初始化数据库以管理员身份运行命令提示符（CMD） 输入以下命令，并且拷贝出来临时密码。 1mysqld --initialize --console 临时密码：.f,o_lza7i4B 1A temporary password is generated for root@localhost: yBSAhjA0nu,E 安装 MySql 服务1mysqld --install 启动服务1net start mysql 登录 MySql在 cmd 中，输入以下命令，登陆 mysql，注意每个同学的临时密码都不同 12345-- mysql -uroot -p临时密码mysql -uroot -p.f,o_lza7i4B1.先输入：mysql -uroot -p ，敲回车2.再输入密码 修改密码1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;12345678&#x27;; 卸载 MySql（了解！！！） 停止 mysql 服务： 1net stop mysql 移除 mysql 服务： 1mysqld --remove 手动删除安装位置的文件夹： 可视化连接工具 Navicat可视化连接工具有很多种，例如：Navicat、Sqlyog，我们本次学习 Navicat 下载 Navicathttps://www.navicat.com.cn/download/navicat-premium 安装 双击 exe 文件，可视化安装即可。 新建连接 Sql 入门数据库、数据表、数据的关系介绍 数据库 用于存储和管理数据的仓库 一个库中可以包含多个数据表 数据表 数据库最重要的组成部分之一 它由纵向的列和横向的行组成(类似 excel 表格) 可以指定列名、数据类型、约束等 一个表中可以存储多条数据 数据 想要永久化存储的数据 SQL 介绍 什么是 SQL Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。 SQL 通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 数据库的注释： 单行注释：– 注释内容 #注释内容(mysql 特有) 多行注释：&#x2F;_ 注释内容 _&#x2F; SQL 分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL-操作数据库R(Retrieve)：查询 查询所有数据库 12-- 查询所有数据库SHOW DATABASES; 查询某个数据库的创建语句 12345-- 标准语法SHOW CREATE DATABASE 数据库名称;-- 查看mysql数据库的创建格式SHOW CREATE DATABASE mysql; C(Create)：创建 创建数据库 123456789-- 标准语法CREATE DATABASE 数据库名称;-- 创建db1数据库CREATE DATABASE db1;-- 创建一个已存在的数据库会报错-- 错误代码：1007 Can&#x27;t create database &#x27;db1&#x27;; database existsCREATE DATABASE db1; 创建数据库(判断，如果不存在则创建) 12345-- 标准语法CREATE DATABASE IF NOT EXISTS 数据库名称;-- 创建数据库db2(判断，如果不存在则创建)CREATE DATABASE IF NOT EXISTS db2; 创建数据库、并指定字符集 12345678-- 标准语法CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称;-- 创建数据库db3、并指定字符集utf8CREATE DATABASE db3 CHARACTER SET utf8;-- 查看db3数据库的字符集SHOW CREATE DATABASE db3; 练习：创建 db4 数据库、如果不存在则创建，指定字符集为 gbk 12345-- 创建db4数据库、如果不存在则创建，指定字符集为gbkCREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk;-- 查看db4数据库的字符集SHOW CREATE DATABASE db4; U(Update)：修改 修改数据库的字符集 12345678-- 标准语法ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;-- 修改数据库db4的字符集为utf8ALTER DATABASE db4 CHARACTER SET utf8;-- 查看db4数据库的字符集SHOW CREATE DATABASE db4; D(Delete)：删除 删除数据库 123456789-- 标准语法DROP DATABASE 数据库名称;-- 删除db1数据库DROP DATABASE db1;-- 删除一个不存在的数据库会报错-- 错误代码：1008 Can&#x27;t drop database &#x27;db1&#x27;; database doesn&#x27;t existDROP DATABASE db1; 删除数据库(判断，如果存在则删除) 12345-- 标准语法DROP DATABASE IF EXISTS 数据库名称;-- 删除数据库db2，如果存在DROP DATABASE IF EXISTS db2; 使用数据库 查询当前正在使用的数据库名称 12-- 查询当前正在使用的数据库SELECT DATABASE(); 使用数据库 12345-- 标准语法USE 数据库名称；-- 使用db4数据库USE db4; DDL-操作数据表R(Retrieve)：查询 查询数据库中所有的数据表 12345-- 使用mysql数据库USE mysql;-- 查询库中所有的表SHOW TABLES; 查询表结构 12345-- 标准语法DESC 表名;-- 查询user表结构DESC user; 查询表字符集 12345-- 标准语法SHOW TABLE STATUS FROM 库名 LIKE &#x27;表名&#x27;;-- 查看mysql数据库中user表字符集SHOW TABLE STATUS FROM mysql LIKE &#x27;user&#x27;; C(Create)：创建创建数据表 标准语法 1234567CREATE TABLE 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n);-- 注意：最后一列，不需要加逗号 数据类型 int：整数类型 age int double:小数类型 score double(5,2) price double date:日期，只包含年月日 yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为 null，则默认使用当前的系统时间，来自动赋值 char：不可变长度字符串 varchar：可变长度字符串 name varchar(20):姓名最大 20 个字符 zhangsan 8 个字符 张三 2 个字符 创建数据表 1234567891011-- 使用db3数据库USE db3;-- 创建一个product商品表CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(30), -- 商品名称 price DOUBLE, -- 商品价格 stock INT, -- 商品库存 insert_time DATE -- 上架时间)ENGINE=InnoDB DEFAULT CHARSET=utf8; 复制表 12345-- 标准语法CREATE TABLE 表名 LIKE 被复制的表名;-- 复制product表到product2表CREATE TABLE product2 LIKE product; U(Update)：修改 修改表名 12345-- 标准语法ALTER TABLE 表名 RENAME TO 新的表名;-- 修改product2表名为product3ALTER TABLE product2 RENAME TO product3; 不建议大家直接去修改表名 可以新建一个表，复制数据到新表即可 不要轻易删除一张表 修改表的字符集 123456789-- 标准语法ALTER TABLE 表名 CHARACTER SET 字符集名称;-- 查看db3数据库中product3数据表字符集SHOW TABLE STATUS FROM db3 LIKE &#x27;product3&#x27;;-- 修改product3数据表字符集为gbkALTER TABLE product3 CHARACTER SET gbk;-- 查看db3数据库中product3数据表字符集SHOW TABLE STATUS FROM db3 LIKE &#x27;product3&#x27;; 添加一列 12345-- 标准语法ALTER TABLE 表名 ADD 列名 数据类型;-- 给product3表添加一列colorALTER TABLE product3 ADD color VARCHAR(10); 修改列名称和数据类型 12345678910111213141516-- 修改数据类型 标准语法ALTER TABLE 表名 MODIFY 列名 新数据类型;-- 将color数据类型修改为intALTER TABLE product3 MODIFY color INT;-- 查看product3表详细信息DESC product3;-- 修改列名和数据类型 标准语法ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;-- 将color修改为address,数据类型为varcharALTER TABLE product3 CHANGE color address VARCHAR(30);-- 查看product3表详细信息DESC product3; 删除列 12345-- 标准语法ALTER TABLE 表名 DROP 列名;-- 删除address列ALTER TABLE product3 DROP address; D(Delete)：删除 删除数据表 123456789-- 标准语法DROP TABLE 表名;-- 删除product3表DROP TABLE product3;-- 删除不存在的表，会报错-- 错误代码：1051 Unknown table &#x27;product3&#x27;DROP TABLE product3; 删除数据表(判断，如果存在则删除) 12345-- 标准语法DROP TABLE IF EXISTS 表名;-- 删除product3表，如果存在则删除DROP TABLE IF EXISTS product3; DML-INSERT 语句新增表数据语法 新增格式 1：给指定列添加数据 1234567891011-- 标准语法INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...);-- 向product表添加一条数据INSERT INTO product(id,NAME,price,stock,insert_time) VALUES (1,&#x27;手机&#x27;,1999,22,&#x27;2099-09-09&#x27;);-- 向product表添加指定列数据INSERT INTO product (id,NAME,price) VALUES (2,&#x27;电脑&#x27;,4999);-- 查看表中所有数据SELECT * FROM product; 新增格式 2：默认给全部列添加数据 12345678-- 标准语法INSERT INTO 表名 VALUES (值1,值2,值3,...);-- 默认给全部列添加数据INSERT INTO product VALUES (3,&#x27;电视&#x27;,2999,18,&#x27;2099-06-06&#x27;);-- 查看表中所有数据SELECT * FROM product; 新增格式 3：批量添加数据 12345678910111213141516-- 默认添加所有列数据 标准语法INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...);-- 批量添加数据INSERT INTO product VALUES (4,&#x27;冰箱&#x27;,999,26,&#x27;2099-08-08&#x27;),(5,&#x27;洗衣机&#x27;,1999,32,&#x27;2099-05-10&#x27;);-- 查看表中所有数据SELECT * FROM product;-- 给指定列添加数据 标准语法INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...),(值1,值2,...);-- 批量添加指定列数据INSERT INTO product (id,NAME,price) VALUES (6,&#x27;微波炉&#x27;,499),(7,&#x27;电磁炉&#x27;,899);-- 查看表中所有数据SELECT * FROM product; 注意事项 列名和值的数量以及数据类型要对应 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引) DML-UPDATE 语句 修改表数据语法 1234567891011121314-- 标准语法UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件];-- 修改手机的价格为3500UPDATE product SET price=3500 WHERE NAME=&#x27;手机&#x27;;-- 查看所有数据SELECT * FROM product;-- 修改电视的价格为1800、库存为36UPDATE product SET price=1800,stock=36 WHERE NAME=&#x27;电视&#x27;;-- 修改电磁炉的库存为10UPDATE product SET stock=10 WHERE id=7; 注意事项 修改语句中必须加条件 如果不加条件，则将所有数据都修改 DML-DELETE 语句 删除表数据语法 1234567891011-- 标准语法DELETE FROM 表名 [WHERE 条件];-- 删除product表中的微波炉信息DELETE FROM product WHERE NAME=&#x27;微波炉&#x27;;-- 删除product表中库存为10的商品信息DELETE FROM product WHERE stock=10;-- 查看所有商品信息SELECT * FROM product; 注意事项 删除语句中必须加条件 如果不加条件，则将所有数据删除 DQL-单表查询 数据准备(直接复制执行即可) 123456789101112131415161718192021222324-- 创建db1数据库CREATE DATABASE db1;-- 使用db1数据库USE db1;-- 创建数据表CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(20), -- 商品名称 price DOUBLE, -- 商品价格 brand VARCHAR(10), -- 商品品牌 stock INT, -- 商品库存 insert_time DATE -- 添加时间);-- 添加数据INSERT INTO product VALUES (1,&#x27;华为手机&#x27;,3999,&#x27;华为&#x27;,23,&#x27;2088-03-10&#x27;),(2,&#x27;小米手机&#x27;,2999,&#x27;小米&#x27;,30,&#x27;2088-05-15&#x27;),(3,&#x27;苹果手机&#x27;,5999,&#x27;苹果&#x27;,18,&#x27;2088-08-20&#x27;),(4,&#x27;华为电脑&#x27;,6999,&#x27;华为&#x27;,14,&#x27;2088-06-16&#x27;),(5,&#x27;小米电脑&#x27;,4999,&#x27;小米&#x27;,26,&#x27;2088-07-08&#x27;),(6,&#x27;苹果电脑&#x27;,8999,&#x27;苹果&#x27;,15,&#x27;2088-10-25&#x27;),(7,&#x27;联想电脑&#x27;,7999,&#x27;联想&#x27;,NULL,&#x27;2088-11-11&#x27;); 查询语法 1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段having 分组之后的条件order by 排序limit 分页限定 查询全部 12345-- 标准语法SELECT * FROM 表名;-- 查询product表所有数据SELECT * FROM product; 查询部分 多个字段查询 12345-- 标准语法SELECT 列名1,列名2,... FROM 表名;-- 查询名称、价格、品牌SELECT NAME,price,brand FROM product; 去除重复查询 注意：只有全部重复的才可以去除 1234567-- 标准语法SELECT DISTINCT 列名1,列名2,... FROM 表名;-- 查询品牌SELECT brand FROM product;-- 查询品牌，去除重复SELECT DISTINCT brand FROM product; 计算列的值(四则运算) 123456789101112131415161718-- 标准语法SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;/* 计算列的值 标准语法： SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; 如果某一列为null，可以进行替换 ifnull(表达式1,表达式2) 表达式1：想替换的列 表达式2：想替换的值*/-- 查询商品名称和库存，库存数量在原有基础上加10SELECT NAME,stock+10 FROM product;-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断SELECT NAME,IFNULL(stock,0)+10 FROM product; 起别名 123456-- 标准语法SELECT 列名1,列名2,... AS 别名 FROM 表名;-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSumSELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product;SELECT NAME,IFNULL(stock,0)+10 getsum FROM product; 条件查询 条件分类 符号 功能 &gt; 大于 &lt; 小于 &gt;&#x3D; 大于等于 &lt;&#x3D; 小于等于 &#x3D; 等于 &lt;&gt; 或 !&#x3D; 不等于 BETWEEN … AND … 在某个范围之内(都包含) IN(…) 多选一 LIKE 占位符 模糊查询 _单个任意字符 %多个任意字符 IS NULL 是 NULL IS NOT NULL 不是 NULL AND 或 &amp;&amp; 并且 OR 或 || 或者 NOT 或 ! 非，不是 条件查询语法 123456789101112131415161718192021222324252627282930313233-- 标准语法SELECT 列名 FROM 表名 WHERE 条件;-- 查询库存大于20的商品信息SELECT * FROM product WHERE stock &gt; 20;-- 查询品牌为华为的商品信息SELECT * FROM product WHERE brand=&#x27;华为&#x27;;-- 查询金额在4000 ~ 6000之间的商品信息SELECT * FROM product WHERE price &gt;= 4000 AND price &lt;= 6000;SELECT * FROM product WHERE price BETWEEN 4000 AND 6000;-- 查询库存为14、30、23的商品信息SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23;SELECT * FROM product WHERE stock IN(14,30,23);-- 查询库存为null的商品信息SELECT * FROM product WHERE stock IS NULL;-- 查询库存不为null的商品信息SELECT * FROM product WHERE stock IS NOT NULL;-- 查询名称以小米为开头的商品信息SELECT * FROM product WHERE NAME LIKE &#x27;小米%&#x27;;-- 查询名称第二个字是为的商品信息SELECT * FROM product WHERE NAME LIKE &#x27;_为%&#x27;;-- 查询名称为四个字符的商品信息SELECT * FROM product WHERE NAME LIKE &#x27;____&#x27;;-- 查询名称中包含电脑的商品信息SELECT * FROM product WHERE NAME LIKE &#x27;%电脑%&#x27;; 聚合函数 将一列数据作为一个整体，进行纵向的计算 聚合函数分类 函数名 功能 count(列名) 统计数量(一般选用不为 null 的列) max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 聚合函数语法 1234567891011121314151617181920212223-- 标准语法SELECT 函数名(列名) FROM 表名 [WHERE 条件];-- 计算product表中总记录条数SELECT COUNT(*) FROM product;-- 获取最高价格SELECT MAX(price) FROM product;-- 获取最高价格的商品名称SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product);-- 获取最低库存SELECT MIN(stock) FROM product;-- 获取最低库存的商品名称SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product);-- 获取总库存数量SELECT SUM(stock) FROM product;-- 获取品牌为苹果的总库存数量SELECT SUM(stock) FROM product WHERE brand=&#x27;苹果&#x27;;-- 获取品牌为小米的平均商品价格SELECT AVG(price) FROM product WHERE brand=&#x27;小米&#x27;; 排序查询 排序分类 注意：多个排序条件，当前边的条件值一样时，才会判断第二条件 关键词 功能 ORDER BY 列名 1 排序方式 1,列名 2 排序方式 2 对指定列排序，ASC 升序(默认的) DESC 降序 排序语法 1234567891011-- 标准语法SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2;-- 按照库存升序排序SELECT * FROM product ORDER BY stock ASC;-- 查询名称中包含手机的商品信息。按照金额降序排序SELECT * FROM product WHERE NAME LIKE &#x27;%手机%&#x27; ORDER BY price DESC;-- 按照金额升序排序，如果金额相同，按照库存降序排列SELECT * FROM product ORDER BY price ASC,stock DESC; 分组查询 1234567891011121314-- 标准语法SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式];-- 按照品牌分组，获取每组商品的总金额SELECT brand,SUM(price) FROM product GROUP BY brand;-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额SELECT brand,SUM(price) FROM product WHERE price &gt; 4000 GROUP BY brand;-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000;-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000 ORDER BY getSum DESC; 分页查询 123456789-- 标准语法SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数;-- 公式：开始索引 = (当前页码-1) * 每页显示的条数-- 每页显示2条数据SELECT * FROM product LIMIT 0,2; -- 第一页 开始索引=(1-1) * 2SELECT * FROM product LIMIT 2,2; -- 第二页 开始索引=(2-1) * 2SELECT * FROM product LIMIT 4,2; -- 第三页 开始索引=(3-1) * 2SELECT * FROM product LIMIT 6,2; -- 第四页 开始索引=(4-1) * 2 分页查询图解 约束约束的概念和分类 约束的概念 对表中的数据进行限定，保证数据的正确性、有效性、完整性！ 约束的分类 约束 说明 PRIMARY KEY 主键约束 PRIMARY KEY AUTO_INCREMENT 主键、自动增长 UNIQUE 唯一约束 NOT NULL 非空约束 FOREIGN KEY 外键约束 FOREIGN KEY ON UPDATE CASCADE 外键级联更新 FOREIGN KEY ON DELETE CASCADE 外键级联删除 主键约束 主键约束特点 主键约束包含：非空和唯一两个功能 主键一般用于表中数据的唯一标识 建表时添加主键约束 1234567891011121314151617181920212223-- 标准语法CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY, 列名 数据类型, ...);-- 创建student表CREATE TABLE student( id INT PRIMARY KEY -- 给id添加主键约束);-- 添加数据INSERT INTO student VALUES (1),(2);-- 主键默认唯一，添加重复数据，会报错INSERT INTO student VALUES (2);-- 主键默认非空，不能添加null的数据INSERT INTO student VALUES (NULL);-- 查询student表SELECT * FROM student;-- 查询student表详细DESC student; 删除主键 12345-- 标准语法ALTER TABLE 表名 DROP PRIMARY KEY;-- 删除主键ALTER TABLE student DROP PRIMARY KEY; 建表后单独添加主键 12345-- 标准语法ALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY;-- 添加主键ALTER TABLE student MODIFY id INT PRIMARY KEY; 主键自动增长约束 建表时添加主键自增约束 123456789101112131415161718192021-- 标准语法CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY AUTO_INCREMENT, 列名 数据类型, ...);-- 创建student2表CREATE TABLE student2( id INT PRIMARY KEY AUTO_INCREMENT -- 给id添加主键自增约束);-- 添加数据INSERT INTO student2 VALUES (1),(2);-- 添加null值，会自动增长INSERT INTO student2 VALUES (NULL),(NULL);-- 查询student2表SELECT * FROM student2;-- student2表详细DESC student2; 删除自动增长 12345-- 标准语法ALTER TABLE 表名 MODIFY 列名 数据类型;-- 删除自动增长ALTER TABLE student2 MODIFY id INT; 建表后单独添加自动增长 12345-- 标准语法ALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT;-- 添加自动增长ALTER TABLE student2 MODIFY id INT AUTO_INCREMENT; 唯一约束 建表时添加唯一约束 12345678910111213141516171819202122-- 标准语法CREATE TABLE 表名( 列名 数据类型 UNIQUE, 列名 数据类型, ...);-- 创建student3表CREATE TABLE student3( id INT PRIMARY KEY AUTO_INCREMENT, tel VARCHAR(20) UNIQUE -- 给tel列添加唯一约束);-- 添加数据INSERT INTO student3 VALUES (NULL,&#x27;18888888888&#x27;),(NULL,&#x27;18666666666&#x27;);-- 添加重复数据，会报错INSERT INTO student3 VALUES (NULL,&#x27;18666666666&#x27;);-- 查询student3数据表SELECT * FROM student3;-- student3表详细DESC student3; 删除唯一约束 12345-- 标准语法ALTER TABLE 表名 DROP INDEX 列名;-- 删除唯一约束ALTER TABLE student3 DROP INDEX tel; 建表后单独添加唯一约束 12345-- 标准语法ALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE;-- 添加唯一约束ALTER TABLE student3 MODIFY tel VARCHAR(20) UNIQUE; 非空约束 建表时添加非空约束 1234567891011121314151617-- 标准语法CREATE TABLE 表名( 列名 数据类型 NOT NULL, 列名 数据类型, ...);-- 创建student4表CREATE TABLE student4( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) NOT NULL -- 给name添加非空约束);-- 添加数据INSERT INTO student4 VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);-- 添加null值，会报错INSERT INTO student4 VALUES (NULL,NULL); 删除非空约束 12345-- 标准语法ALTER TABLE 表名 MODIFY 列名 数据类型;-- 删除非空约束ALTER TABLE student4 MODIFY NAME VARCHAR(20); 建表后单独添加非空约束 12345-- 标准语法ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL;-- 添加非空约束ALTER TABLE student4 MODIFY NAME VARCHAR(20) NOT NULL; 外键约束 外键约束概念 让表和表之间产生关系，从而保证数据的准确性！ 建表时添加外键约束 为什么要有外键约束 123456789101112131415161718192021222324252627282930-- 创建db2数据库CREATE DATABASE db2;-- 使用db2数据库USE db2;-- 创建user用户表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(20) NOT NULL -- 姓名);-- 添加用户数据INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;),(NULL,&#x27;王五&#x27;);-- 创建orderlist订单表CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- id number VARCHAR(20) NOT NULL, -- 订单编号 uid INT -- 订单所属用户);-- 添加订单数据INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2),(NULL,&#x27;hm005&#x27;,3),(NULL,&#x27;hm006&#x27;,3);-- 添加一个订单，但是没有所属用户。这合理吗？INSERT INTO orderlist VALUES (NULL,&#x27;hm007&#x27;,8);-- 删除王五这个用户，但是订单表中王五还有很多个订单呢。这合理吗？DELETE FROM USER WHERE NAME=&#x27;王五&#x27;;-- 所以我们需要添加外键约束，让两张表产生关系 外键约束格式 1CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) 创建表添加外键约束 123456789101112131415161718192021222324-- 创建user用户表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(20) NOT NULL -- 姓名);-- 添加用户数据INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;),(NULL,&#x27;王五&#x27;);-- 创建orderlist订单表CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- id number VARCHAR(20) NOT NULL, -- 订单编号 uid INT, -- 订单所属用户 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) -- 添加外键约束);-- 添加订单数据INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2),(NULL,&#x27;hm005&#x27;,3),(NULL,&#x27;hm006&#x27;,3);-- 添加一个订单，但是没有所属用户。无法添加INSERT INTO orderlist VALUES (NULL,&#x27;hm007&#x27;,8);-- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除DELETE FROM USER WHERE NAME=&#x27;王五&#x27;; 删除外键约束 12345-- 标准语法ALTER TABLE 表名 DROP FOREIGN KEY 外键名;-- 删除外键ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1; 建表后添加外键约束 12345-- 标准语法ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);-- 添加外键约束ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id); 外键的级联更新和级联删除(了解) 什么是级联更新和级联删除 当我想把 user 用户表中的某个用户删掉，我希望该用户所有的订单也随之被删除 当我想把 user 用户表中的某个用户 id 修改，我希望订单表中该用户所属的订单用户编号也随之修改 添加级联更新和级联删除 123456789101112131415161718192021-- 添加外键约束，同时添加级联更新 标准语法ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE;-- 添加外键约束，同时添加级联删除 标准语法ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON DELETE CASCADE;-- 添加外键约束，同时添加级联更新和级联删除 标准语法ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE ON DELETE CASCADE;-- 删除外键约束ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1;-- 添加外键约束，同时添加级联更新和级联删除ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ON UPDATE CASCADE ON DELETE CASCADE;-- 将王五用户的id修改为5 订单表中的uid也随之被修改UPDATE USER SET id=5 WHERE id=3;-- 将王五用户删除 订单表中该用户所有订单也随之删除DELETE FROM USER WHERE id=5; 多表设计一对一(了解) 分析 人和身份证。一个人只有一个身份证，一个身份证只能对应一个人！ 实现原则 在任意一个表建立外键，去关联另外一个表的主键 SQL 演示 12345678910111213141516171819202122-- 创建db5数据库CREATE DATABASE db5;-- 使用db5数据库USE db5;-- 创建person表CREATE TABLE person( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));-- 添加数据INSERT INTO person VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);-- 创建card表CREATE TABLE card( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(50), pid INT UNIQUE, CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id) -- 添加外键);-- 添加数据INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1),(NULL,&#x27;56789&#x27;,2); 图解 一对多 分析 用户和订单。一个用户可以有多个订单！ 商品分类和商品。一个分类下可以有多个商品！ 实现原则 在多的一方，建立外键约束，来关联一的一方主键 SQL 演示 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 用户和订单*/-- 创建user表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));-- 添加数据INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);-- 创建orderlist表CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(20), uid INT, CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) -- 添加外键约束);-- 添加数据INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2);/* 商品分类和商品*/-- 创建category表CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10));-- 添加数据INSERT INTO category VALUES (NULL,&#x27;手机数码&#x27;),(NULL,&#x27;电脑办公&#x27;);-- 创建product表CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), cid INT, CONSTRAINT pc_fk1 FOREIGN KEY (cid) REFERENCES category(id) -- 添加外键约束);-- 添加数据INSERT INTO product VALUES (NULL,&#x27;华为P30&#x27;,1),(NULL,&#x27;小米note3&#x27;,1),(NULL,&#x27;联想电脑&#x27;,2),(NULL,&#x27;苹果电脑&#x27;,2); 图解 多对多 分析 学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择！ 实现原则 需要借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键 SQL 演示 1234567891011121314151617181920212223242526-- 创建student表CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));-- 添加数据INSERT INTO student VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);-- 创建course表CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10));-- 添加数据INSERT INTO course VALUES (NULL,&#x27;语文&#x27;),(NULL,&#x27;数学&#x27;);-- 创建中间表CREATE TABLE stu_course( id INT PRIMARY KEY AUTO_INCREMENT, sid INT, -- 用于和student表的id进行外键关联 cid INT, -- 用于和course表的id进行外键关联 CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束 CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id) -- 添加外键约束);-- 添加数据INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2); 图解 多表查询多表查询-数据准备创建表 user （用户表） orderlist （订单列表） category （商品分类） product （商品） us_pro （用户和商品的中间表） SQL 语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101-- 创建db6数据库CREATE DATABASE db6;-- 使用db6数据库USE db6;-- 创建user表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- 用户id NAME VARCHAR(20), -- 用户姓名 age INT -- 用户年龄);-- 添加数据INSERT INTO USER VALUES (1,&#x27;张三&#x27;,23);INSERT INTO USER VALUES (2,&#x27;李四&#x27;,24);INSERT INTO USER VALUES (3,&#x27;王五&#x27;,25);INSERT INTO USER VALUES (4,&#x27;赵六&#x27;,26);-- 订单表CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- 订单id number VARCHAR(30), -- 订单编号 uid INT, -- 外键字段 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id));-- 添加数据INSERT INTO orderlist VALUES (1,&#x27;hm001&#x27;,1);INSERT INTO orderlist VALUES (2,&#x27;hm002&#x27;,1);INSERT INTO orderlist VALUES (3,&#x27;hm003&#x27;,2);INSERT INTO orderlist VALUES (4,&#x27;hm004&#x27;,2);INSERT INTO orderlist VALUES (5,&#x27;hm005&#x27;,3);INSERT INTO orderlist VALUES (6,&#x27;hm006&#x27;,3);INSERT INTO orderlist VALUES (7,&#x27;hm007&#x27;,NULL);-- 商品分类表CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品分类id NAME VARCHAR(10) -- 商品分类名称);-- 添加数据INSERT INTO category VALUES (1,&#x27;手机数码&#x27;);INSERT INTO category VALUES (2,&#x27;电脑办公&#x27;);INSERT INTO category VALUES (3,&#x27;烟酒茶糖&#x27;);INSERT INTO category VALUES (4,&#x27;鞋靴箱包&#x27;);-- 商品表CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品id NAME VARCHAR(30), -- 商品名称 cid INT, -- 外键字段 CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id));-- 添加数据INSERT INTO product VALUES (1,&#x27;华为手机&#x27;,1);INSERT INTO product VALUES (2,&#x27;小米手机&#x27;,1);INSERT INTO product VALUES (3,&#x27;联想电脑&#x27;,2);INSERT INTO product VALUES (4,&#x27;苹果电脑&#x27;,2);INSERT INTO product VALUES (5,&#x27;中华香烟&#x27;,3);INSERT INTO product VALUES (6,&#x27;玉溪香烟&#x27;,3);INSERT INTO product VALUES (7,&#x27;计生用品&#x27;,NULL);-- 中间表CREATE TABLE us_pro( upid INT PRIMARY KEY AUTO_INCREMENT, -- 中间表id uid INT, -- 外键字段。需要和用户表的主键产生关联 pid INT, -- 外键字段。需要和商品表的主键产生关联 CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id), CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id));-- 添加数据INSERT INTO us_pro VALUES (NULL,1,1);INSERT INTO us_pro VALUES (NULL,1,2);INSERT INTO us_pro VALUES (NULL,1,3);INSERT INTO us_pro VALUES (NULL,1,4);INSERT INTO us_pro VALUES (NULL,1,5);INSERT INTO us_pro VALUES (NULL,1,6);INSERT INTO us_pro VALUES (NULL,1,7);INSERT INTO us_pro VALUES (NULL,2,1);INSERT INTO us_pro VALUES (NULL,2,2);INSERT INTO us_pro VALUES (NULL,2,3);INSERT INTO us_pro VALUES (NULL,2,4);INSERT INTO us_pro VALUES (NULL,2,5);INSERT INTO us_pro VALUES (NULL,2,6);INSERT INTO us_pro VALUES (NULL,2,7);INSERT INTO us_pro VALUES (NULL,3,1);INSERT INTO us_pro VALUES (NULL,3,2);INSERT INTO us_pro VALUES (NULL,3,3);INSERT INTO us_pro VALUES (NULL,3,4);INSERT INTO us_pro VALUES (NULL,3,5);INSERT INTO us_pro VALUES (NULL,3,6);INSERT INTO us_pro VALUES (NULL,3,7);INSERT INTO us_pro VALUES (NULL,4,1);INSERT INTO us_pro VALUES (NULL,4,2);INSERT INTO us_pro VALUES (NULL,4,3);INSERT INTO us_pro VALUES (NULL,4,4);INSERT INTO us_pro VALUES (NULL,4,5);INSERT INTO us_pro VALUES (NULL,4,6);INSERT INTO us_pro VALUES (NULL,4,7); 架构器图解 连接查询图示 多表查询-笛卡尔积查询(了解) 有两张表，获取这两个表的所有组合情况 要完成多表查询，需要消除这些没有用的数据 多表查询格式 123456SELECT 列名列表FROM 表名列表WHERE 条件... 笛卡尔积查询 12345-- 标准语法SELECT 列名 FROM 表名1,表名2,...;-- 查询user表和orderlist表SELECT * FROM USER,orderlist; 多表查询-内连接查询 查询原理 内连接查询的是两张表有交集的部分数据(有主外键关联的数据) 显式内连接 1234567891011121314151617181920212223-- 标准语法SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件;-- 查询用户信息和对应的订单信息SELECT * FROM USER INNER JOIN orderlist ON user.id=orderlist.uid;SELECT * FROM USER JOIN orderlist ON user.id=orderlist.uid;-- 查询用户信息和对应的订单信息，起别名SELECT * FROM USER u JOIN orderlist o ON u.id=o.uid;-- 查询用户姓名，年龄。和订单编号SELECT u.id, u.`NAME`, u.age, o.id oid, o.numberFROM `USER` uINNER JOIN orderlist oON u.id = o.uid; 隐式内连接 12345678910111213-- 标准语法SELECT 列名 FROM 表名1,表名2 WHERE 条件;-- 查询用户姓名，年龄。和订单编号SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号FROM USER u, -- 用户表 orderlist o -- 订单表WHERE u.`id`=o.`uid`; 多表查询-外连接查询 左外连接 查询原理 查询左表的全部数据，和左右两张表有交集部分的数据 基本演示 1234567891011121314-- 标准语法SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件;-- 查询所有用户信息，以及用户对应的订单信息SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号FROM USER u -- 用户表LEFT OUTER JOIN orderlist o -- 订单表ON u.`id`=o.`uid`; 右外连接 查询原理 查询右表的全部数据，和左右两张表有交集部分的数据 基本演示 1234567891011121314-- 基本语法SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件;-- 查询所有订单信息，以及订单所属的用户信息SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号FROM USER u -- 用户表RIGHT OUTER JOIN orderlist o -- 订单表ON u.`id`=o.`uid`; 多表查询-子查询 子查询介绍 查询语句中嵌套了查询语句。我们就将嵌套查询称为子查询！ 子查询-结果是单行单列的 可以作为条件，使用运算符进行判断！ 基本演示 1234567-- 标准语法SELECT 列名 FROM 表名 WHERE 列名=(SELECT 聚合函数(列名) FROM 表名 [WHERE 条件]);-- 查询年龄最高的用户姓名SELECT MAX(age) FROM USER; -- 查询出最高年龄SELECT NAME,age FROM USER WHERE age=26; -- 根据查询出来的最高年龄，查询姓名和年龄SELECT NAME,age FROM USER WHERE age = (SELECT MAX(age) FROM USER); 子查询-结果是多行单列的 可以作为条件，使用运算符 in 或 not in 进行判断！ 基本演示 1234567-- 标准语法SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]);-- 查询张三和李四的订单信息SELECT id FROM USER WHERE NAME=&#x27;张三&#x27; OR NAME=&#x27;李四&#x27;; -- 查询张三和李四用户的idSELECT number,uid FROM orderlist WHERE uid=1 OR uid=2; -- 根据id查询订单SELECT number,uid FROM orderlist WHERE uid IN (SELECT id FROM USER WHERE NAME=&#x27;张三&#x27; OR NAME=&#x27;李四&#x27;); 子查询-结果是多行多列的 可以作为一张虚拟表参与查询！ 基本演示 12345-- 标准语法SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];-- 查询订单表中id大于4的订单信息和所属用户信息SELECT * FROM USER u,(SELECT * FROM orderlist WHERE id&gt;4) o WHERE u.id=o.uid; 多表查询练习 查询用户的编号、姓名、年龄。订单编号 123456789101112131415/*分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid*/SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号FROM USER t1, -- 用户表 orderlist t2 -- 订单表WHERE t1.`id` = t2.`uid`; 查询所有的用户。用户的编号、姓名、年龄。订单编号 1234567891011121314151617/*分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid 查询所有用户，使用左外连接*/SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号FROM USER t1 -- 用户表LEFT OUTER JOIN orderlist t2 -- 订单表ON t1.`id` = t2.`uid`; 查询所有的订单。用户的编号、姓名、年龄。订单编号 1234567891011121314151617/*分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid 查询所有订单，使用右外连接*/SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号FROM USER t1 -- 用户表RIGHT OUTER JOIN orderlist t2 -- 订单表ON t1.`id` = t2.`uid`; 查询用户年龄大于 23 岁的信息。显示用户的编号、姓名、年龄。订单编号 1234567891011121314151617181920212223242526272829303132/*分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.age &gt; 23 AND user.id = orderlist.uid*//*select t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号from user t1, -- 用户表 orderlist t2 -- 订单表where t1.`age` &gt; 23 and t1.`id` = t2.`uid`;*/SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号FROM USER t1 -- 用户表LEFT OUTER JOIN orderlist t2 -- 订单表ON t1.`id` = t2.`uid`WHERE t1.`age` &gt; 23; 查询张三和李四用户的信息。显示用户的编号、姓名、年龄。订单编号 123456789101112131415161718/*分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid AND user.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;);*/SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号FROM USER t1, -- 用户表 orderlist t2 -- 订单表WHERE t1.`id` = t2.`uid` AND -- (t1.`name` = &#x27;张三&#x27; OR t1.`name` = &#x27;李四&#x27;); t1.`name` IN (&#x27;张三&#x27;,&#x27;李四&#x27;); 查询商品分类的编号、分类名称。分类下的商品名称 1234567891011121314/*分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid*/SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称FROM category t1, -- 商品分类表 product t2 -- 商品表WHERE t1.`id` = t2.`cid`; 查询所有的商品分类。商品分类的编号、分类名称。分类下的商品名称 12345678910111213141516/*分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid 查询所有的商品分类，使用左外连接*/SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称FROM category t1 -- 商品分类表LEFT OUTER JOIN product t2 -- 商品表ON t1.`id` = t2.`cid`; 查询所有的商品信息。商品分类的编号、分类名称。分类下的商品名称 12345678910111213141516/*分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid 查询所有的商品信息，使用右外连接*/SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称FROM category t1 -- 商品分类表RIGHT OUTER JOIN product t2 -- 商品表ON t1.`id` = t2.`cid`; 查询所有的用户和所有的商品。显示用户的编号、姓名、年龄。商品名称 123456789101112131415161718/*分析： 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid = user.id AND us_pro.pid = product.id*/SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户名称 t1.`age`, -- 用户年龄 t2.`name` -- 商品名称FROM USER t1, -- 用户表 product t2, -- 商品表 us_pro t3 -- 中间表WHERE t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`; 查询张三和李四这两个用户可以看到的商品。显示用户的编号、姓名、年龄。商品名称 12345678910111213141516171819/*分析： 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid = user.id AND us_pro.pid = product.id AND user.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;)*/SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户名称 t1.`age`, -- 用户年龄 t2.`name` -- 商品名称FROM USER t1, -- 用户表 product t2, -- 商品表 us_pro t3 -- 中间表WHERE (t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`) AND -- (t1.`name` = &#x27;张三&#x27; or t1.`name` = &#x27;李四&#x27;); t1.`name` IN (&#x27;张三&#x27;,&#x27;李四&#x27;); 多表查询-自关联查询自关联查询介绍 同一张表中有数据关联。可以多次查询这同一个表！ 案例原始数据表： 实现效果 自关联查询演示123456789101112131415161718192021222324252627282930313233343536373839-- 创建员工表CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), mgr INT, salary DOUBLE);-- 添加数据INSERT INTO employee VALUES(1001,&#x27;孙悟空&#x27;,1005,9000.00),(1002,&#x27;猪八戒&#x27;,1005,8000.00),(1003,&#x27;沙和尚&#x27;,1005,8500.00),(1004,&#x27;小白龙&#x27;,1005,7900.00),(1005,&#x27;唐僧&#x27;,NULL,15000.00),(1006,&#x27;武松&#x27;,1009,7600.00),(1007,&#x27;李逵&#x27;,1009,7400.00),(1008,&#x27;林冲&#x27;,1009,8100.00),(1009,&#x27;宋江&#x27;,NULL,16000.00);-- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询/*分析： 员工姓名 employee表 直接上级姓名 employee表 条件：employee.mgr = employee.id 查询左表的全部数据，和左右两张表交集部分数据，使用左外连接*/SELECT t1.name, -- 员工姓名 t1.mgr, -- 上级编号 t2.id mgr_id, -- 员工编号 t2.name mgr_name -- 员工领导姓名FROM employee t1 -- 员工表LEFT OUTER JOIN employee t2 -- 员工表ON t1.mgr = t2.id; 视图视图的概念 视图是一种虚拟存在的数据表 这个虚拟的表并不在数据库中实际存在 作用是将一些比较复杂的查询语句的结果，封装到一个虚拟表中。后期再有相同复杂查询时，直接查询这张虚拟表即可 说白了，视图就是将一条 SELECT 查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条 SELECT 查询语句上 视图的好处 简单 对于使用视图的用户不需要关心表的结构、关联条件和筛选条件。因为这张虚拟表中保存的就是已经过滤好条件的结果集 安全 视图可以设置权限 , 致使访问视图的用户只能访问他们被允许查询的结果集 数据独立 一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响 视图数据准备 1234567891011121314151617181920212223-- 创建db7数据库CREATE DATABASE db7;-- 使用db7数据库USE db7;-- 创建country表CREATE TABLE country( id INT PRIMARY KEY AUTO_INCREMENT, country_name VARCHAR(30));-- 添加数据INSERT INTO country VALUES (NULL,&#x27;中国&#x27;),(NULL,&#x27;美国&#x27;),(NULL,&#x27;俄罗斯&#x27;);-- 创建city表CREATE TABLE city( id INT PRIMARY KEY AUTO_INCREMENT, city_name VARCHAR(30), cid INT, -- 外键列。关联country表的主键列id CONSTRAINT cc_fk1 FOREIGN KEY (cid) REFERENCES country(id));-- 添加数据INSERT INTO city VALUES (NULL,&#x27;北京&#x27;,1),(NULL,&#x27;上海&#x27;,1),(NULL,&#x27;纽约&#x27;,2),(NULL,&#x27;莫斯科&#x27;,3); 视图的创建 创建视图语法 12-- 标准语法CREATE VIEW 视图名称 [(列名列表)] AS 查询语句; 普通多表查询，查询城市和所属国家 1234567891011-- 普通多表查询，查询城市和所属国家SELECT t1.*, t2.country_nameFROM city t1, country t2WHERE t1.cid = t2.id;-- 经常需要查询这样的数据，就可以创建一个视图 创建视图基本演示 123456-- 创建一个视图。将查询出来的结果保存到这张虚拟表中CREATEVIEW city_countryAS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 创建视图并指定列名基本演示 1234567-- 创建一个视图，指定列名。将查询出来的结果保存到这张虚拟表中CREATEVIEW city_country2 (city_id,city_name,cid,country_name)AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 视图的查询 查询视图语法 12-- 标准语法SELECT * FROM 视图名称; 查询视图基本演示 12345678-- 查询视图。查询这张虚拟表，就等效于查询城市和所属国家SELECT * FROM city_country;-- 查询指定列名的视图SELECT * FROM city_country2;-- 查询所有数据表，视图也会查询出来SHOW TABLES; 查询视图创建语法 12-- 标准语法SHOW CREATE VIEW 视图名称; 查询视图创建语句基本演示 1SHOW CREATE VIEW city_country; 视图的修改 修改视图表中的数据 12345678910111213-- 标准语法UPDATE 视图名称 SET 列名=值 WHERE 条件;-- 修改视图表中的城市名称北京为北京市UPDATE city_country SET city_name=&#x27;北京市&#x27; WHERE city_name=&#x27;北京&#x27;;-- 查询视图SELECT * FROM city_country;-- 查询city表,北京也修改为了北京市SELECT * FROM city;-- 注意：视图表数据修改，会自动修改源表中的数据 修改视图表结构 123456789101112-- 标准语法ALTER VIEW 视图名称 [(列名列表)] AS 查询语句;-- 查询视图2SELECT * FROM city_country2;-- 修改视图2的列名city_id为idALTERVIEW city_country2 (id,city_name,cid,country_name)AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 视图的删除 删除视图 12345678-- 标准语法DROP VIEW [IF EXISTS] 视图名称;-- 删除视图DROP VIEW city_country;-- 删除视图2，如果存在则删除DROP VIEW IF EXISTS city_country2; 视图的总结 视图是一种虚拟存在的数据表 这个虚拟的表并不在数据库中实际存在 说白了，视图就是将一条 SELECT 查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条 SELECT 查询语句上 视图的好处 简单 安全 数据独立 MySQL 存储过程和函数存储过程和函数的概念 存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合 存储过程和函数的好处 存储过程和函数可以重复使用，减轻开发人员的工作量。类似于 java 中方法可以多次调用 减少网络流量，存储过程和函数位于服务器上，调用的时候只需要传递名称和参数即可 减少数据在数据库和应用服务器之间的传输，可以提高数据处理的效率 将一些业务逻辑在数据库层面来实现，可以减少代码层面的业务处理 存储过程和函数的区别 函数必须有返回值 存储过程没有返回值 创建存储过程 小知识 1234567/* 该关键字用来声明sql语句的分隔符，告诉MySQL该段命令已经结束！ sql语句默认的分隔符是分号，但是有的时候我们需要一条功能sql语句中包含分号，但是并不作为结束标识。 这个时候就可以使用DELIMITER来指定分隔符了！*/-- 标准语法DELIMITER 分隔符 数据准备 1234567891011121314151617181920-- 创建db8数据库CREATE DATABASE db8;-- 使用db8数据库USE db8;-- 创建学生表CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, -- 学生id NAME VARCHAR(20), -- 学生姓名 age INT, -- 学生年龄 gender VARCHAR(5), -- 学生性别 score INT -- 学生成绩);-- 添加数据INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,&#x27;男&#x27;,95),(NULL,&#x27;李四&#x27;,24,&#x27;男&#x27;,98),(NULL,&#x27;王五&#x27;,25,&#x27;女&#x27;,100),(NULL,&#x27;赵六&#x27;,26,&#x27;女&#x27;,90);-- 按照性别进行分组，查询每组学生的总成绩。按照总成绩的升序排序SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; 创建存储过程语法 1234567891011-- 修改分隔符为$DELIMITER $-- 标准语法CREATE PROCEDURE 存储过程名称(参数...)BEGIN sql语句;END$-- 修改分隔符为分号DELIMITER ; 创建存储过程 1234567891011-- 修改分隔符为$DELIMITER $-- 创建存储过程，封装分组查询学生总成绩的sql语句CREATE PROCEDURE stu_group()BEGIN SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC;END$-- 修改分隔符为分号DELIMITER ; 调用存储过程 调用存储过程语法 12345-- 标准语法CALL 存储过程名称(实际参数);-- 调用stu_group存储过程CALL stu_group(); 查看存储过程 查看存储过程语法 12-- 查询数据库中所有的存储过程 标准语法SELECT * FROM mysql.proc WHERE db=&#x27;数据库名称&#x27;; 删除存储过程 删除存储过程语法 12345-- 标准语法DROP PROCEDURE [IF EXISTS] 存储过程名称;-- 删除stu_group存储过程DROP PROCEDURE stu_group; 存储过程语法存储过程语法介绍 存储过程是可以进行编程的。意味着可以使用变量、表达式、条件控制语句、循环语句等，来完成比较复杂的功能！ 变量的使用 定义变量 1234567891011121314151617-- 标准语法DECLARE 变量名 数据类型 [DEFAULT 默认值];-- 注意： DECLARE定义的是局部变量，只能用在BEGIN END范围之内-- 定义一个int类型变量、并赋默认值为10DELIMITER $CREATE PROCEDURE pro_test1()BEGIN DECLARE num INT DEFAULT 10; -- 定义变量 SELECT num; -- 查询变量END$DELIMITER ;-- 调用pro_test1存储过程CALL pro_test1(); 变量的赋值 1 1234567891011121314151617-- 标准语法SET 变量名 = 变量值;-- 定义字符串类型变量，并赋值DELIMITER $CREATE PROCEDURE pro_test2()BEGIN DECLARE NAME VARCHAR(10); -- 定义变量 SET NAME = &#x27;存储过程&#x27;; -- 为变量赋值 SELECT NAME; -- 查询变量END$DELIMITER ;-- 调用pro_test2存储过程CALL pro_test2(); 变量的赋值 2 123456789101112131415161718-- 标准语法SELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件];-- 定义两个int变量，用于存储男女同学的总分数DELIMITER $CREATE PROCEDURE pro_test3()BEGIN DECLARE men,women INT; -- 定义变量 SELECT SUM(score) INTO men FROM student WHERE gender=&#x27;男&#x27;; -- 计算男同学总分数赋值给men SELECT SUM(score) INTO women FROM student WHERE gender=&#x27;女&#x27;; -- 计算女同学总分数赋值给women SELECT men,women; -- 查询变量END$DELIMITER ;-- 调用pro_test3存储过程CALL pro_test3(); if 语句的使用 标准语法 123456-- 标准语法IF 判断条件1 THEN 执行的sql语句1;[ELSEIF 判断条件2 THEN 执行的sql语句2;]...[ELSE 执行的sql语句n;]END IF; 案例演示 1234567891011121314151617181920212223242526272829303132333435/* 定义一个int变量，用于存储班级总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般*/DELIMITER $CREATE PROCEDURE pro_test4()BEGIN -- 定义总分数变量 DECLARE total INT; -- 定义分数描述变量 DECLARE description VARCHAR(10); -- 为总分数变量赋值 SELECT SUM(score) INTO total FROM student; -- 判断总分数 IF total &gt;= 380 THEN SET description = &#x27;学习优秀&#x27;; ELSEIF total &gt;= 320 AND total &lt; 380 THEN SET description = &#x27;学习不错&#x27;; ELSE SET description = &#x27;学习一般&#x27;; END IF; -- 查询总成绩和描述信息 SELECT total,description;END$DELIMITER ;-- 调用pro_test4存储过程CALL pro_test4(); 参数的传递 参数传递的语法 12345678910111213DELIMITER $-- 标准语法CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型)BEGIN 执行的sql语句;END$/* IN:代表输入参数，需要由调用者传递实际数据。默认的 OUT:代表输出参数，该参数可以作为返回值 INOUT:代表既可以作为输入参数，也可以作为输出参数*/DELIMITER ; 输入参数 标准语法 123456789DELIMITER $-- 标准语法CREATE PROCEDURE 存储过程名称(IN 参数名 数据类型)BEGIN 执行的sql语句;END$DELIMITER ; 案例演示 1234567891011121314151617181920212223242526272829303132/* 输入总成绩变量，代表学生总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般*/DELIMITER $CREATE PROCEDURE pro_test5(IN total INT)BEGIN -- 定义分数描述变量 DECLARE description VARCHAR(10); -- 判断总分数 IF total &gt;= 380 THEN SET description = &#x27;学习优秀&#x27;; ELSEIF total &gt;= 320 AND total &lt; 380 THEN SET description = &#x27;学习不错&#x27;; ELSE SET description = &#x27;学习一般&#x27;; END IF; -- 查询总成绩和描述信息 SELECT total,description;END$DELIMITER ;-- 调用pro_test5存储过程CALL pro_test5(390);CALL pro_test5((SELECT SUM(score) FROM student)); 输出参数 标准语法 123456789DELIMITER $-- 标准语法CREATE PROCEDURE 存储过程名称(OUT 参数名 数据类型)BEGIN 执行的sql语句;END$DELIMITER ; 案例演示 1234567891011121314151617181920212223242526272829/* 输入总成绩变量，代表学生总成绩 输出分数描述变量，代表学生总成绩的描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般*/DELIMITER $CREATE PROCEDURE pro_test6(IN total INT,OUT description VARCHAR(10))BEGIN -- 判断总分数 IF total &gt;= 380 THEN SET description = &#x27;学习优秀&#x27;; ELSEIF total &gt;= 320 AND total &lt; 380 THEN SET description = &#x27;学习不错&#x27;; ELSE SET description = &#x27;学习一般&#x27;; END IF;END$DELIMITER ;-- 调用pro_test6存储过程CALL pro_test6(310,@description);-- 查询总成绩描述SELECT @description; 小知识 123@变量名: 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。@@变量名: 这种在变量前加上 &quot;@@&quot; 符号, 叫做系统变量 case 语句的使用 标准语法 1 1234567-- 标准语法CASE 表达式WHEN 值1 THEN 执行sql语句1;[WHEN 值2 THEN 执行sql语句2;]...[ELSE 执行sql语句n;]END CASE; 标准语法 2 1234567-- 标准语法CASEWHEN 判断条件1 THEN 执行sql语句1;[WHEN 判断条件2 THEN 执行sql语句2;]...[ELSE 执行sql语句n;]END CASE; 案例演示 123456789101112131415161718192021222324252627282930313233/* 输入总成绩变量，代表学生总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般*/DELIMITER $CREATE PROCEDURE pro_test7(IN total INT)BEGIN -- 定义变量 DECLARE description VARCHAR(10); -- 使用case判断 CASE WHEN total &gt;= 380 THEN SET description = &#x27;学习优秀&#x27;; WHEN total &gt;= 320 AND total &lt; 380 THEN SET description = &#x27;学习不错&#x27;; ELSE SET description = &#x27;学习一般&#x27;; END CASE; -- 查询分数描述信息 SELECT description;END$DELIMITER ;-- 调用pro_test7存储过程CALL pro_test7(390);CALL pro_test7((SELECT SUM(score) FROM student)); while 循环 标准语法 123456-- 标准语法初始化语句;WHILE 条件判断语句 DO 循环体语句; 条件控制语句;END WHILE; 案例演示 123456789101112131415161718192021222324252627282930/* 计算1~100之间的偶数和*/DELIMITER $CREATE PROCEDURE pro_test8()BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- while循环 WHILE num &lt;= 100 DO -- 偶数判断 IF num%2=0 THEN SET result = result + num; -- 累加 END IF; -- 让num+1 SET num = num + 1; END WHILE; -- 查询求和结果 SELECT result;END$DELIMITER ;-- 调用pro_test8存储过程CALL pro_test8(); repeat 循环 标准语法 123456789-- 标准语法初始化语句;REPEAT 循环体语句; 条件控制语句; UNTIL 条件判断语句END REPEAT;-- 注意：repeat循环是条件满足则停止。while循环是条件满足则执行 案例演示 123456789101112131415161718192021222324252627282930/* 计算1~10之间的和*/DELIMITER $CREATE PROCEDURE pro_test9()BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- repeat循环 REPEAT -- 累加 SET result = result + num; -- 让num+1 SET num = num + 1; -- 停止循环 UNTIL num&gt;10 END REPEAT; -- 查询求和结果 SELECT result;END$DELIMITER ;-- 调用pro_test9存储过程CALL pro_test9(); loop 循环 标准语法 1234567891011-- 标准语法初始化语句;[循环名称:] LOOP 条件判断语句 [LEAVE 循环名称;] 循环体语句; 条件控制语句;END LOOP 循环名称;-- 注意：loop可以实现简单的循环，但是退出循环需要使用其他的语句来定义。我们可以使用leave语句完成！-- 如果不加退出循环的语句，那么就变成了死循环。 案例演示 1234567891011121314151617181920212223242526272829303132/* 计算1~10之间的和*/DELIMITER $CREATE PROCEDURE pro_test10()BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- loop循环 l:LOOP -- 条件成立，停止循环 IF num &gt; 10 THEN LEAVE l; END IF; -- 累加 SET result = result + num; -- 让num+1 SET num = num + 1; END LOOP l; -- 查询求和结果 SELECT result;END$DELIMITER ;-- 调用pro_test10存储过程CALL pro_test10(); 游标 游标的概念 游标可以遍历返回的多行结果，每次拿到一整行数据 在存储过程和函数中可以使用游标对结果集进行循环的处理 简单来说游标就类似于集合的迭代器遍历 MySQL 中的游标只能用在存储过程和函数中 游标的语法 创建游标 12-- 标准语法DECLARE 游标名称 CURSOR FOR 查询sql语句; 打开游标 12-- 标准语法OPEN 游标名称; 使用游标获取数据 12-- 标准语法FETCH 游标名称 INTO 变量名1,变量名2,...; 关闭游标 12-- 标准语法CLOSE 游标名称; 游标的基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108-- 创建stu_score表CREATE TABLE stu_score( id INT PRIMARY KEY AUTO_INCREMENT, score INT);/* 将student表中所有的成绩保存到stu_score表中*/DELIMITER $CREATE PROCEDURE pro_test11()BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 创建游标,查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 开启游标 OPEN stu_result; -- 使用游标，遍历结果,拿到第1行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第2行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第3行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第4行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 关闭游标 CLOSE stu_result;END$DELIMITER ;-- 调用pro_test11存储过程CALL pro_test11();-- 查询stu_score表SELECT * FROM stu_score;-- ===========================================================/* 出现的问题： student表中一共有4条数据，我们在游标遍历了4次，没有问题！ 但是在游标中多遍历几次呢？就会出现问题*/DELIMITER $CREATE PROCEDURE pro_test11()BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 创建游标,查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 开启游标 OPEN stu_result; -- 使用游标，遍历结果,拿到第1行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第2行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第3行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第4行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第5行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 关闭游标 CLOSE stu_result;END$DELIMITER ;-- 调用pro_test11存储过程CALL pro_test11();-- 查询stu_score表,虽然数据正确，但是在执行存储过程时会报错SELECT * FROM stu_score; 游标的优化使用(配合循环使用) 12345678910/* 当游标结束后，会触发游标结束事件。我们可以通过这一特性来完成循环操作 加标记思想： 1.定义一个变量，默认值为0(意味着有数据) 2.当游标结束后，将变量值改为1(意味着没有数据了)*/-- 1.定义一个变量，默认值为0(意味着有数据)DECLARE flag INT DEFAULT 0;-- 2.当游标结束后，将变量值改为1(意味着没有数据了)DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1; 123456789101112131415161718192021222324252627282930313233343536373839/* 将student表中所有的成绩保存到stu_score表中*/DELIMITER $CREATE PROCEDURE pro_test12()BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 定义标记变量 DECLARE flag INT DEFAULT 0; -- 创建游标，查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 游标结束后，将标记变量改为1 DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1; -- 开启游标 OPEN stu_result; -- 循环使用游标 REPEAT -- 使用游标，遍历结果,拿到数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); UNTIL flag=1 END REPEAT; -- 关闭游标 CLOSE stu_result;END$DELIMITER ;-- 调用pro_test12存储过程CALL pro_test12();-- 查询stu_score表SELECT * FROM stu_score; 存储过程的总结 存储过程是 事先经过编译并存储在数据库中的一段 SQL 语句的集合。可以在数据库层面做一些业务处理 说白了存储过程其实就是将 sql 语句封装为方法，然后可以调用方法执行 sql 语句而已 存储过程的好处 安全 高效 复用性强 存储函数存储函数和存储过程是非常相似的。存储函数可以做的事情，存储过程也可以做到！ 存储函数有返回值，存储过程没有返回值(参数的 out 其实也相当于是返回数据了) 标准语法 创建存储函数 1234567891011DELIMITER $-- 标准语法CREATE FUNCTION 函数名称([参数 数据类型])RETURNS 返回值类型BEGIN 执行的sql语句; RETURN 结果;END$DELIMITER ; 调用存储函数 12-- 标准语法SELECT 函数名称(实际参数); 删除存储函数 12-- 标准语法DROP FUNCTION 函数名称; 案例演示 1234567891011121314151617181920/* 定义存储函数，获取学生表中成绩大于95分的学生数量*/DELIMITER $CREATE FUNCTION fun_test1()RETURNS INTBEGIN -- 定义统计变量 DECLARE result INT; -- 查询成绩大于95分的学生数量，给统计变量赋值 SELECT COUNT(*) INTO result FROM student WHERE score &gt; 95; -- 返回统计结果 RETURN result;END$DELIMITER ;-- 调用fun_test1存储函数SELECT fun_test1(); 上面函数在创建的时候，可能会报以下错误 1&gt; 1418 - This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable) 这是我们开启了 bin-log, 我们就必须指定我们的函数是否是 12345DETERMINISTIC 确定性的NO SQL 没有SQl语句，当然也不会修改数据READS SQL DATA 只是读取数据，当然也不会修改数据MODIFIES SQL DATA 要修改数据CONTAINS SQL 包含了SQL语句 其中在 function 里面，只有 DETERMINISTIC, NO SQL 和 READS SQL DATA 被支持。如果我们开启了 bin-log, 我们就必须为我们的 function 指定一个参数。 在 MySQL 中创建函数时出现这种错误的解决方法： 1set global log_bin_trust_function_creators=TRUE; MySQL 触发器触发器的概念 触发器是与表有关的数据库对象，可以在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的 SQL 语句。触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 。 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 OLD 的含义 NEW 的含义 INSERT 型触发器 无 (因为插入前状态无数据) NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 无 (因为删除后状态无数据) 创建触发器 标准语法 1234567891011DELIMITER $CREATE TRIGGER 触发器名称BEFORE|AFTER INSERT|UPDATE|DELETEON 表名[FOR EACH ROW] -- 行级触发器BEGIN 触发器要执行的功能;END$DELIMITER ; 触发器演示。通过触发器记录账户表的数据变更日志。包含：增加、修改、删除 创建账户表 1234567891011121314-- 创建db9数据库CREATE DATABASE db9;-- 使用db9数据库USE db9;-- 创建账户表accountCREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, -- 账户id NAME VARCHAR(20), -- 姓名 money DOUBLE -- 余额);-- 添加数据INSERT INTO account VALUES (NULL,&#x27;张三&#x27;,1000),(NULL,&#x27;李四&#x27;,2000); 创建日志表 12345678-- 创建日志表account_logCREATE TABLE account_log( id INT PRIMARY KEY AUTO_INCREMENT, -- 日志id operation VARCHAR(20), -- 操作类型 (insert update delete) operation_time DATETIME, -- 操作时间 operation_id INT, -- 操作表的id operation_params VARCHAR(200) -- 操作参数); 创建 INSERT 触发器 123456789101112131415161718192021-- 创建INSERT触发器DELIMITER $CREATE TRIGGER account_insertAFTER INSERTON accountFOR EACH ROWBEGIN INSERT INTO account_log VALUES (NULL,&#x27;INSERT&#x27;,NOW(),new.id,CONCAT(&#x27;插入后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));END$DELIMITER ;-- 向account表添加记录INSERT INTO account VALUES (NULL,&#x27;王五&#x27;,3000);-- 查询account表SELECT * FROM account;-- 查询日志表SELECT * FROM account_log; 创建 UPDATE 触发器 123456789101112131415161718192021-- 创建UPDATE触发器DELIMITER $CREATE TRIGGER account_updateAFTER UPDATEON accountFOR EACH ROWBEGIN INSERT INTO account_log VALUES (NULL,&#x27;UPDATE&#x27;,NOW(),new.id,CONCAT(&#x27;修改前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;,&#x27;修改后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));END$DELIMITER ;-- 修改account表UPDATE account SET money=3500 WHERE id=3;-- 查询account表SELECT * FROM account;-- 查询日志表SELECT * FROM account_log; 创建 DELETE 触发器 123456789101112131415161718192021-- 创建DELETE触发器DELIMITER $CREATE TRIGGER account_deleteAFTER DELETEON accountFOR EACH ROWBEGIN INSERT INTO account_log VALUES (NULL,&#x27;DELETE&#x27;,NOW(),old.id,CONCAT(&#x27;删除前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;));END$DELIMITER ;-- 删除account表数据DELETE FROM account WHERE id=3;-- 查询account表SELECT * FROM account;-- 查询日志表SELECT * FROM account_log; 查看触发器12345-- 标准语法SHOW TRIGGERS;-- 查看触发器SHOW TRIGGERS; 删除触发器12345-- 标准语法DROP TRIGGER 触发器名称;-- 删除DELETE触发器DROP TRIGGER account_delete; 触发器的总结 触发器是与表有关的数据库对象 可以在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的 SQL 语句 触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容 MySQL 事务事务的概念 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败，单元中的每条 SQL 语句都相互依赖，形成一个整体，如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态，如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行。 事务的数据准备1234567891011121314-- 创建db10数据库CREATE DATABASE db10;-- 使用db10数据库USE db10;-- 创建账户表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, -- 账户id NAME VARCHAR(20), -- 账户名称 money DOUBLE -- 账户余额);-- 添加数据INSERT INTO account VALUES (NULL,&#x27;张三&#x27;,1000),(NULL,&#x27;李四&#x27;,1000); 未管理事务演示12345678-- 张三给李四转账500元-- 1.张三账户-500UPDATE account SET money=money-500 WHERE NAME=&#x27;张三&#x27;;-- 2.李四账户+500出错了...UPDATE account SET money=money+500 WHERE NAME=&#x27;李四&#x27;;-- 该场景下，这两条sql语句要么同时成功，要么同时失败。就需要被事务所管理！ 管理事务演示 操作事务的三个步骤 开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败 执行 sql 语句：执行具体的一条或多条 sql 语句 结束事务(提交|回滚) 提交：没出现问题，数据进行更新 回滚：出现问题，数据恢复到开启事务时的状态 开启事务 12-- 标准语法START TRANSACTION; 回滚事务 12-- 标准语法ROLLBACK; 提交事务 12-- 标准语法COMMIT; 管理事务演示 123456789101112131415161718-- 开启事务START TRANSACTION;-- 张三给李四转账500元-- 1.张三账户-500UPDATE account SET money=money-500 WHERE NAME=&#x27;张三&#x27;;-- 2.李四账户+500-- 出错了...UPDATE account SET money=money+500 WHERE NAME=&#x27;李四&#x27;;-- 查询账户情况select * from account;-- 回滚事务(出现问题)ROLLBACK;-- 提交事务(没出现问题)COMMIT; 事务的提交方式 提交方式 自动提交(MySQL 默认为自动提交) 手动提交 修改提交方式 查看提交方式 12-- 标准语法SELECT @@AUTOCOMMIT; -- 1代表自动提交 0代表手动提交 修改提交方式 12345678-- 标准语法SET @@AUTOCOMMIT=数字;-- 修改为手动提交SET @@AUTOCOMMIT=0;-- 查看提交方式SELECT @@AUTOCOMMIT; 事务的四大特征(ACID) 原子性(atomicity) 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响 一致性(consistency) 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态 拿转账来说，假设张三和李四两者的钱加起来一共是 2000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 2000，这就是事务的一致性 隔离性(isolcation) 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性(durability) 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作 事务的隔离级别 隔离级别的概念 多个客户端操作时 ,各个客户端的事务之间应该是隔离的，相互独立的 , 不受影响的。 而如果多个事务操作同一批数据时，则需要设置不同的隔离级别 , 否则就会产生问题 。 我们先来了解一下四种隔离级别的名称 , 再来看看可能出现的问题 四种隔离级别 1 读未提交 read uncommitted 2 读已提交 read committed 3 可重复读 repeatable read 4 串行化 serializable 可能引发的问题 问题 现象 脏读 是指在一个事务处理过程中读取了另一个未提交的事务中的数据 , 导致两次查询结果不一致 不可重复读 是指在一个事务处理过程中读取了另一个事务中修改并已提交的数据, 导致两次查询结果不一致 幻读 select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入。或不存在执行 delete 删除，却发现删除成功 查询数据库隔离级别 12-- 标准语法SELECT @@TX_ISOLATION; 修改数据库隔离级别 12345678-- 标准语法SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;-- 修改数据库隔离级别为read uncommittedSET GLOBAL TRANSACTION ISOLATION LEVEL read uncommitted;-- 查看隔离级别SELECT @@TX_ISOLATION; -- 修改后需要断开连接重新开 事务隔离级别演示 脏读的问题 窗口 1 1234567891011121314151617-- 查询账户表select * from account;-- 设置隔离级别为read uncommittedset global transaction isolation level read uncommitted;-- 开启事务start transaction;-- 转账update account set money = money - 500 where id = 1;update account set money = money + 500 where id = 2;-- 窗口2查询转账结果 ,出现脏读(查询到其他事务未提交的数据)-- 窗口2查看转账结果后，执行回滚rollback; 窗口 2 12345678-- 查询隔离级别select @@transaction_isolation;-- 开启事务start transaction;-- 查询账户表select * from account; 解决脏读的问题和演示不可重复读的问题 窗口 1 12345678910111213141516-- 设置隔离级别为read committedset global transaction isolation level read committed;-- 开启事务start transaction;-- 转账update account set money = money - 500 where id = 1;update account set money = money + 500 where id = 2;-- 窗口2查看转账结果，并没有发生变化(脏读问题被解决了)-- 执行提交事务。commit;-- 窗口2查看转账结果，数据发生了变化(出现了不可重复读的问题，读取到其他事务已提交的数据) 窗口 2 12345678-- 查询隔离级别select @@transaction_isolation;-- 开启事务start transaction;-- 查询账户表select * from account; 解决不可重复读的问题 窗口 1 12345678910111213141516-- 设置隔离级别为repeatable readset global transaction isolation level repeatable read;select @@transaction_isolation;-- 开启事务start transaction;-- 转账update account set money = money - 500 where id = 1;update account set money = money + 500 where id = 2;-- 窗口2查看转账结果，并没有发生变化-- 执行提交事务commit;-- 这个时候窗口2只要还在上次事务中，看到的结果都是相同的。只有窗口2结束事务，才能看到变化(不可重复读的问题被解决) 窗口 2 1234567891011121314-- 查询隔离级别select @@transaction_isolation;-- 开启事务start transaction;-- 查询账户表select * from account;-- 提交事务commit;-- 查询账户表select * from account; 幻读的问题和解决 窗口 1 1234567891011121314-- 设置隔离级别为repeatable readset global transaction isolation level repeatable read;-- 开启事务start transaction;-- 添加一条记录INSERT INTO account VALUES (3,&#x27;王五&#x27;,1500);-- 查询账户表，本窗口可以查看到id为3的结果SELECT * FROM account;-- 提交事务COMMIT; 窗口 2 1234567891011121314151617-- 查询隔离级别select @@tx_isolation;-- 开启事务start transaction;-- 查询账户表，查询不到新添加的id为3的记录select * from account;-- 添加id为3的一条数据，发现添加失败。出现了幻读INSERT INTO account VALUES (3,&#x27;测试&#x27;,200);-- 提交事务COMMIT;-- 查询账户表，查询到了新添加的id为3的记录select * from account; 解决幻读的问题 12345678910111213141516171819202122232425262728293031323334353637/* 窗口1*/-- 设置隔离级别为serializableset global transaction isolation level serializable;-- 开启事务start transaction;-- 添加一条记录INSERT INTO account VALUES (4,&#x27;赵六&#x27;,1600);-- 查询账户表，本窗口可以查看到id为4的结果SELECT * FROM account;-- 提交事务COMMIT;/* 窗口2*/-- 查询隔离级别select @@tx_isolation;-- 开启事务start transaction;-- 查询账户表，发现查询语句无法执行，数据表被锁住！只有窗口1提交事务后，才可以继续操作select * from account;-- 添加id为4的一条数据，发现已经存在了，就不会再添加了！幻读的问题被解决INSERT INTO account VALUES (4,&#x27;测试&#x27;,200);-- 提交事务COMMIT; 隔离级别总结 隔离级别 名称 出现脏读 出现不可重复读 出现幻读 数据库默认隔离级别 1 read uncommitted 读未提交 是 是 是 2 read committed 读已提交 否 是 是 Oracle &#x2F; SQL Server 3 repeatable read 可重复读 否 否 是 MySQL 4 **serializable ** 串行化 否 否 否 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 , 所以不建议使用 READ UNCOMMITTED 和 SERIALIZABLE 隔离级别. 事务的总结 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败。例如转账操作 开启事务：start transaction; 回滚事务：rollback; 提交事务：commit; 事务四大特征 原子性 持久性 隔离性 一致性 事务的隔离级别 read uncommitted(读未提交) read committed (读已提交) repeatable read (可重复读) serializable (串行化)","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"力扣1031","slug":"力扣1031","date":"2023-04-26T06:15:00.000Z","updated":"2023-04-26T06:34:41.535Z","comments":true,"path":"2023/04/26/力扣1031/","link":"","permalink":"http://example.com/2023/04/26/%E5%8A%9B%E6%89%A31031/","excerpt":"#两个非重叠子数组的最大和","text":"#两个非重叠子数组的最大和 1031. 两个非重叠子数组的最大和 - 力扣（LeetCode）前缀和+动态规划：首先用前缀数组可以快速求出数组中两点中的元素的和，首先应该想象到找到first的元素的和，去遍历second的和找到最大和时间复杂度O(n^2),应该不难想到。 用动态规划去解决问题时，遍历一遍找到最大一个first的值，很简单就想到用一个 sum&#x3D;max(sum,s[i]-s[i-first]); 解决问题， 但是问题是求两端的和 有个方法很难想到，我反正是想不到，首先first与second的大小不同导致不清楚答案是谁在前谁在后 所以分开考虑假如second在前，则有在每次找first的最大时刻后面更新答案， sum &#x3D; max(sum,s[i-first]-s[i-first-second]); ans &#x3D; max(ans,sum+s[i]-s[i-first]); 同理另一种情况也是一样最终得出答案. 1234567891011121314151617181920212223class Solution &#123;public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; nums, int firstLen, int secondLen) &#123; int s[1001],n = nums.size(); s[0]=0; for(int i=1,sum=0;i&lt;=n;i++) &#123; sum+=nums[i-1]; s[i] = sum; &#125; int sum1=0,sum2=0,ans1=0,ans2=0; for(int i=firstLen+secondLen;i&lt;=n;i++) &#123; sum1 = max(sum1,s[i-secondLen]-s[i-secondLen-firstLen]); ans1 = max(ans1,sum1+s[i]-s[i-secondLen]); sum2 = max(sum2,s[i-firstLen]-s[i-firstLen-secondLen]); ans2 = max(ans2,sum2+s[i]-s[i-firstLen]); &#125; return max(ans1,ans2); &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"力扣1043和368","slug":"力扣1043和368","date":"2023-04-19T02:23:00.000Z","updated":"2023-04-19T12:34:42.457Z","comments":true,"path":"2023/04/19/力扣1043和368/","link":"","permalink":"http://example.com/2023/04/19/%E5%8A%9B%E6%89%A31043%E5%92%8C368/","excerpt":"#动态规划两道题","text":"#动态规划两道题 1043. 分隔数组以得到最大和 - 力扣（LeetCode）方法一（过不了）：树状数组＋dfs用dfs暴力搜索时间复杂度为指数型，用树状数组优化，但还是指数型 介绍一下树状数组： 【五分钟丝滑动画讲解 | 树状数组】 https://www.bilibili.com/video/BV1ce411u7qP/?share_source=copy_web&amp;vd_source=c9899d0504fa271ca6db5ef82d1a6bbb 树状数组的作用， 1.以O(logN)找到一个下表的 i 到 j 的和 2.以O(logN)更新一个下表的数字 3.空间复杂度为O(N) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;int&gt; tr; int lowerBit(int i) &#123; return (i&amp;-i); &#125; void add(int i,int z) &#123; for(;i&lt;tr.size();i+=lowerBit(i)) &#123; tr[i]+=z; &#125; &#125; int query(int i) &#123; int res=0; for(;i&gt;0;i-=lowerBit(i)) &#123; res+=tr[i]; &#125; return res; &#125;//树状数组的定义 int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; tr = vector&lt;int&gt;(arr.size()+1,0); int ma=0; function&lt;void(int)&gt; dfs = [&amp;](int dex)&#123; if(dex==arr.size())//下表超出，找到总和 &#123; ma = max(ma,query(tr.size()-1)); return; &#125; int res=0; for(int i=dex;i&lt;arr.size()&amp;&amp;i-dex&lt;k;i++) &#123; res = max(res,arr[i]); for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,res); &#125; dfs(i+1);//更新tr，递归后删除更新的数值 for(int j=dex+1;j&lt;=i+1;j++) &#123; add(j,-res); &#125; &#125; &#125;; dfs(0); return ma; &#125; &#125;; 方法二：dp简单分析一下找到数组的最大值，就是找到n的位置于n的前k项进行组合找到最大值 dp中储存的就是当前下表大小的数组的和最大值 推出动态方程 dp[i] &#x3D; max(dp[i],dp[j]+valmax*(i-j)); 12345678910111213141516171819class Solution &#123;public: int maxSumAfterPartitioning(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; pd(arr.size()+1,0); //多一个是为了让以dp[0]=0开头，让下表i存的是前i项之和包括i for(int i=1;i&lt;arr.size()+1;i++) &#123; int maxv=arr[i-1]; for(int j=i-1;j&gt;=0&amp;&amp;i-j&lt;=k;j--) &#123; pd[i] = max(pd[i],pd[j]+(i-j)*maxv); if(j&gt;0) maxv = max(maxv,arr[j-1]); &#125; &#125; return pd[arr.size()]; &#125; &#125;; 时间复杂度O(NK) 空间是O(N) 368. 最大整除子集 - 力扣（LeetCode）dp+数学（简单的数学）：数学方面就是：在一个集合中使各个元素的最大公因数，最小公倍数是两个数本身 也就是说一个数能被另一个数整除 一个大于集合的所有数判断是否能被集合中所有元素整除，只需要判断能被集合中最大的数整除 所以先对nums排序 dp方程为dp[i] &#x3D; max(dp[j]+1); 保存最大的值，从最大的值开始往前找，找到连续可行的子序列 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;int&gt;ans; vector&lt;pair&lt;int,int&gt;&gt; mp(nums.size(),&#123;0,-1&#125;); int ma=-1,biao=0; for(int i=0;i&lt;nums.size();i++) &#123; for(int j=i-1;j&gt;=0;j--) &#123; if(nums[i]%nums[j]==0&amp;&amp;mp[i].first&lt;mp[j].first) &#123; mp[i].first = mp[j].first; mp[i].second = j; &#125; &#125; mp[i].first++; if(ma&lt;mp[i].first) &#123; ma = mp[i].first; biao = i; &#125; &#125; while(biao&gt;=0) &#123; ans.push_back(nums[biao]); biao = mp[biao].second; &#125; return ans; &#125;&#125;; 时间复杂度O(N^2) 空间复杂度O(2N)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"疫情在家有感","slug":"疫情在家有感","date":"2022-12-05T09:16:25.279Z","updated":"2022-12-05T09:27:16.914Z","comments":true,"path":"2022/12/05/疫情在家有感/","link":"","permalink":"http://example.com/2022/12/05/%E7%96%AB%E6%83%85%E5%9C%A8%E5%AE%B6%E6%9C%89%E6%84%9F/","excerpt":"我感觉吧，与其去羡慕别人的生活，不如好好享受自己的生活，哪怕你不喜欢。","text":"我感觉吧，与其去羡慕别人的生活，不如好好享受自己的生活，哪怕你不喜欢。 因为时间有限，每个人的时间都有限，你羡慕的人又高又帅，社交能力还强有很多朋友，孤独寂寞总轮不到他，但让自己处于羡慕这种人的痛苦之中，不如享受属于自己的快乐，或许这辈子也享受不到高富帅的快乐，但他们或许也享受不到屌丝的快乐，他的一生，我的一生都是美好的 浑浑噩噩的一天又要结束喽！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"wallhaven爬虫","slug":"wallhaven爬虫","date":"2022-12-04T16:19:14.000Z","updated":"2022-12-05T08:17:31.078Z","comments":true,"path":"2022/12/05/wallhaven爬虫/","link":"","permalink":"http://example.com/2022/12/05/wallhaven%E7%88%AC%E8%99%AB/","excerpt":"py爬取壁纸（setu）wallhaven网站爬取","text":"py爬取壁纸（setu）wallhaven网站爬取 刚开始爬的时候一切顺利，但最后遇到了反爬虫机制，就是必须要登录，否则无法显示一些色图。 首先想到的就是py模拟登录，这里说两种解法： ​ 1.在post请求中把账号，密码输入，一般都不会成功，应为会有js加密，这里可以解密，具体我也不了解就不往下说了 ​ 2.可行且简单的方法，用cookie绕过去，先说一下cookie的概念，在客户端对服务器发送请求，服务器会产生客户端的记录，来得知客户端之前做过什么，就比如你登录了bilbil，关了之后，在进入就免登录了，这之间就是cookie的功劳，让服务器记得你，回归正题，模拟登录就是首先你要登录这个网站，再记录cookie，爬取的headers填上cookie，让后就进入登录后的界面了，就可以下载图片了 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport parselimport osfor shuzi in range(1,75): print(f&quot;正在下载第&#123;shuzi&#125;页&quot;) url = &#x27;https://wallhaven.cc/hot?page=&#x27; #头请求就不展示了 headers = &#123; &#x27;user - agent&#x27;:#！！！这个网站的反爬虫机制就是登录，用cookie绕过登录----&gt; ,&#x27;cookie&#x27; : &#125; req = requests.get(url+str(shuzi),headers=headers,cookies=cook) print(url+str(shuzi)) sele = parsel.Selector(req.text) lis = sele.css(&#x27;.preview&#x27;) for li in lis: pic_url = li.css(&#x27;.preview ::attr(href)&#x27;).get() print(pic_url) pos = requests.get(pic_url,headers=headers,verify=False) pic_sele = parsel.Selector(pos.text) pic_lis = pic_sele.xpath(&#x27;//div[@class=&quot;scrollbox&quot;]//img/@src&#x27;).getall() print(pic_lis) for pic_urll in pic_lis: pic = requests.get(pic_urll,headers=headers,verify=False).content pic_name = pic_urll.split(&#x27;/&#x27;)[-1] if not os.path.exists(f&#x27;..//&#123;pic_name&#125;&#x27;): with open(f&#x27;..//&#123;pic_name&#125;&#x27;,&#x27;wb&#x27;) as f: f.write(pic) print(&#x27; 完成图片&#x27;+pic_name) else: print(&#x27; 已存在&#x27;+pic_name) 图片壁纸需要自取下面是wallhaven网站热门壁纸，果然色图是人的第一生产力，因为不能上传太多，就随便传了几张，可以尝试自己爬取哦","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"小齐的第一篇博客","slug":"齐振豪的第一篇博客","date":"2022-12-01T10:13:23.000Z","updated":"2023-04-19T12:35:07.319Z","comments":true,"path":"2022/12/01/齐振豪的第一篇博客/","link":"","permalink":"http://example.com/2022/12/01/%E9%BD%90%E6%8C%AF%E8%B1%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"#进来听听歌","text":"#进来听听歌 恭喜你，成功打开我的第一篇博客。 祝你的人生一路顺风，加油","categories":[],"tags":[]}]